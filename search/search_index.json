{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CoDriven Advanced UI documentation version 1.0.0 Thank you for buying CoDriven Advanced UI. I hope it will speed up your workflow and help to finish your game faster \ud83d\ude04. CoDriven Advanced UI documentation version 1.0.0 The main benefits of CoDriven Advanced UI is: Note: this tool include: FULLY working 3D multiplayer FPS (mirror/LAN) with : Limitations of the current version of CoDriven Advanced UI: CoDriven Advanced UI components Screen Manager (CmScreenManager) Screen (CmScreen) Theme (ICmThemeBase) Screen Part (CmScreenPart) Controls Modifiers UI events Tutorials The main benefits of CoDriven Advanced UI is: full source code included build in nodes with screen preview so you can connect them by actions and use these actions to move between screens, but you can move between screens without it by just a simple method call with screen name (more about here) easy language change and translation editor (built-in) (more about here) easy theming and changing of the current theme! (more about here) easy and powerful styling but in the code - no more CSS/USS! and much easier, because you will not modify text style for any component :) (more about here) , easily add your own custom Editors in Unity. You can check how Translation Editor was made - because it was made with its own code I mean CoDriven Advanced UI :) really easy event handling! (you can handle events on part of your screen, screen as a whole, globally, or event in many places at the same time) (more about here) CoDriven Advanced UI contains controls from UI Toolkit and a few more, like a floating window, and a draggable panel. This will be probably improved in the future (more about here) implemented with observer pattern in mind to observe changes in UI or trigger UI changes from external events (more about here) multiple scenes with examples like simple one theme, simple two themes, a few game scenes with maps and main menu, other (more about here) easy passing player data to UI by event callback helper functions for your game and tools for multiplayer with a mirror **included: FULLY working 3D multiplayer FPS (mirror/LAN) with main menu and in-game menu ** click here Note: this tool include: FULLY working 3D multiplayer FPS (mirror/LAN) with : grappling hook weapon created from scratch using math in code for springs (without using the build in spring classes), so you can do more, car driving logic: spring camera attached to the seat and shooting while driving + free camera rotation + FPP/TPP camera during driving \ud83d\ude04, car models includec (not top quality \ud83d\ude04) weapon recoil using spring, weapon attached to the hand bone jumping muzzle flashes, sounds for actions, health status fully working menu settings changes like resolution/refresh rate, sound, music, mouse sensitivity, and more multiple weapons like pistol, machinegun, grenade launcher, sniper with simple zooming, rocket launcher (all model included with blender files .blend) weapon recoil maps for the game and simple models like trees, houses, you can play with friends :) More about multiplayer games click here Please read the below brief overview of all important sections that will help you to understand how it works all together. Limitations of the current version of CoDriven Advanced UI: CoDriven Advanced UI is styling controls by generating USS code in the background. The system will generate all styles for all your themes and selectors from the code to the Resources/UssStyles folder and it will be loaded runtime. Limitation: currently UIToolkit enforces the limitation that USS code can't created and parsed runtime to style sheet because The USS importer makes heavy use of the AssetDatabase to resolve asset paths. To make the importer runtime-ready, the UI Toolkit needs to come up with other ways to resolve asset paths. So that you can change any style of your controls (during project creation in the editor) for any selector for example : Hover when the mouse is hovering over the control. This can be done before the final build and will work runtime, but we can't generate runtime a new style. CoDriven Advanced UI will build all styles and selectors for all you screens before final build so that you will be able to use it runtime normally, but you won't be able to generate styles runtime. You can of course change styles runtime by using fields from controls but not by USS code. Because of that the new version of CoDriven Advanced UI will propably depend only on dynamic code generation, but current version is enought - it works like UI Toolkit, so don't worry. So, we can: create styles for any visual look before build and set at runtime to change it dynamically runtime, create custom selectors and activate/deactivate it runtime (that will change the visual look and feel of control for certain conditions) dynamically change the visual of any control by accessing the stylesheet property of any CmControl.getVisualElement() .stylesheet. So we can for example dynamically load any image and change it runtime. Because of all of that - CoDriven Advanced UI has an additional custom selector that will allow you to execute runtime. So you want to make control half opacity and red in certain conditions runtime. You will create that style for it with your custom name and activate or deactivate that style runtime. Important!. The next version of the CoDriven Advanced UI will be probably fully based on dynamic changes without using CSS/USS so any dynamic changes runtime would be dynamic by default. Anyway - all the unity UI Toolkit selectors will work normally in runtime, so you will normally create a style for each selector you want. For example when the mouse is hovered, when control is disabled, or checked: var cmToggle = new CmToggle (..); cmToogle . modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other state using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . BorderWidth ( 0 ) . BorderRadius ( 60 . px ()) . BorderColorRGBA ( new Color32 ( 255 , 51 , 4 , 255 )) //Now add modifiers for HOVER state . ____NextSelector ( CmSelector . HOVER ) . Scale ( 1.2f ) //Now add modifiers for the DISABLED state . ____NextSelector ( CmSelector . DISABLED ) . BackgroundColorRGBA ( Color . white ) //Now add modifiers for the CHECKED state . ____NextSelector ( CmSelector . CHECKED ) . BackgroundColorRGBA ( Color . gray ) ); to learn more about changing visual look see theming , modifiers and controls CoDriven Advanced UI components Screen Manager (CmScreenManager) The main component of CoDriven Advanced UI is CmScreenManager which is a container for all screens and themes in your game. You can create many screen managers. For example: One for the main menu, and one for in-game. You Provide a list of * CmScreen * and a list of Themes CmThemeBase. Here you can handle global UI events by clicking on the buttons. To learn more about it click here Screen (CmScreen) This is a single screen visible as a whole on the monitor screen currently. The screen is tightly coupled with a theme. If you don't use a theme then you can create a screen based on the default theme. Here you can handle screen-related UI events like clicking on the buttons. To learn more about it click here Theme (ICmThemeBase) The theme is just a base Interface inherited after ICmThemeBase which you will provide. It will contain methods like: public interface CmExample1ThemeBase : ICmThemeBase { public void StyleButton ( CmButton button ); } You will tell Screen Manager, or Screen that this interface will be used for theming, and create classes that will inherit this interface to actually style your control with the implemented method. So you can use the base interface when you create control and you won't worry about which theme is currently in use. You can have as many themes as you want and easily change theme runtime. To learn more about theming click here Screen Part (CmScreenPart) This is an optional element. It was added to divide the whole screen into sections. This way you can reuse certain sections on multiple screens. Like the game settings panel for changes in the main menu and in the game. This way it's more reusable. CmScreenPart is also usable to handle UI events (like button clicks or other events) and encapsulate this logic to this screen part. Of course, you can handle events in higher order parts of your system like CmScreen or * CmScreenManager * you can handle screen part-related UI events like clicking on the buttons. To learn more about CmScreenPart click here Controls CoDriven Advanced UI is an adapter for UI toolkit components with an extension. You can easily modify UI Toolkit controls as usual that are attached to adaptee control. but you can easily handle UI events and styling without needing the \"USS/CSS\" part. To see all available controls at the moment please click here Modifiers Modifiers are properties that will change the look and feel of UI Toolkit controls like USS/CSS code, but they are managed in the code. Modifiers were divided into categories to make it more intuitive while modifying the control style. So for example you can have control with text that will have CmModifierBackground and more extensive modifier * CmModifierText for Text elements like labels. It doesn't make sense to use text modifiers on images. But * CmModifierText is an extension of CmModifierBackground** so you can use all properties from the background on the text element but you cannot use the text element on the background. CmModifierText - for styling elements with text, CmModifierBackground - for elements with background, CmModifierImageAndBackground - for images, CmModifierColumn and CmModifierRow - for column and row components, to get more information about modifiers click here UI events UIEvents are mapped internally to simple Class. This way you can easily use events in any place of your elements tree. The whole menu is built onto CmScreenManager , and next CmScreen which is attached to CmScreenManager , and next CmScreenPart (optional) which is attached to CmScreen, and finally, CmControlBase which is added to CmScreenPart. So basically there is a relation like this CmScreenManager <- CmScreen <- CmScreenPart <- CmControl You can handle events the same way. The UI events are generated by CmControl. This event can be handled inside the function that creates CmControl, or upper in CmScreenPart or upper CmScreen, or globally in CmScreenManager. This way you can have a button \"Change theme to My favorite\" and handle click event (generated by this button) globally in CmScreenManager. This way you will not repeat code related to changing themes inside each visible screen. More about UI events here . Tutorials CoDriven Advanced UI contains a few sample scenes but it will be better to read the tutorial section first (here)","title":"Overview"},{"location":"index.html#codriven-advanced-ui-documentation-version-100","text":"Thank you for buying CoDriven Advanced UI. I hope it will speed up your workflow and help to finish your game faster \ud83d\ude04. CoDriven Advanced UI documentation version 1.0.0 The main benefits of CoDriven Advanced UI is: Note: this tool include: FULLY working 3D multiplayer FPS (mirror/LAN) with : Limitations of the current version of CoDriven Advanced UI: CoDriven Advanced UI components Screen Manager (CmScreenManager) Screen (CmScreen) Theme (ICmThemeBase) Screen Part (CmScreenPart) Controls Modifiers UI events Tutorials","title":"CoDriven Advanced UI documentation version 1.0.0"},{"location":"index.html#the-main-benefits-of-codriven-advanced-ui-is","text":"full source code included build in nodes with screen preview so you can connect them by actions and use these actions to move between screens, but you can move between screens without it by just a simple method call with screen name (more about here)","title":"The main benefits of CoDriven Advanced UI is:"},{"location":"index.html#_1","text":"easy language change and translation editor (built-in) (more about here) easy theming and changing of the current theme! (more about here) easy and powerful styling but in the code - no more CSS/USS! and much easier, because you will not modify text style for any component :) (more about here) , easily add your own custom Editors in Unity. You can check how Translation Editor was made - because it was made with its own code I mean CoDriven Advanced UI :) really easy event handling! (you can handle events on part of your screen, screen as a whole, globally, or event in many places at the same time) (more about here) CoDriven Advanced UI contains controls from UI Toolkit and a few more, like a floating window, and a draggable panel. This will be probably improved in the future (more about here) implemented with observer pattern in mind to observe changes in UI or trigger UI changes from external events (more about here) multiple scenes with examples like simple one theme, simple two themes, a few game scenes with maps and main menu, other (more about here) easy passing player data to UI by event callback helper functions for your game and tools for multiplayer with a mirror **included: FULLY working 3D multiplayer FPS (mirror/LAN) with main menu and in-game menu ** click here","title":""},{"location":"index.html#note-this-tool-include-fully-working-3d-multiplayer-fps-mirrorlan-with","text":"grappling hook weapon created from scratch using math in code for springs (without using the build in spring classes), so you can do more, car driving logic: spring camera attached to the seat and shooting while driving + free camera rotation + FPP/TPP camera during driving \ud83d\ude04, car models includec (not top quality \ud83d\ude04) weapon recoil using spring, weapon attached to the hand bone jumping muzzle flashes, sounds for actions, health status fully working menu settings changes like resolution/refresh rate, sound, music, mouse sensitivity, and more multiple weapons like pistol, machinegun, grenade launcher, sniper with simple zooming, rocket launcher (all model included with blender files .blend) weapon recoil maps for the game and simple models like trees, houses, you can play with friends :) More about multiplayer games click here Please read the below brief overview of all important sections that will help you to understand how it works all together.","title":"Note: this tool include: FULLY working 3D multiplayer FPS (mirror/LAN) with:"},{"location":"index.html#limitations-of-the-current-version-of-codriven-advanced-ui","text":"CoDriven Advanced UI is styling controls by generating USS code in the background. The system will generate all styles for all your themes and selectors from the code to the Resources/UssStyles folder and it will be loaded runtime. Limitation: currently UIToolkit enforces the limitation that USS code can't created and parsed runtime to style sheet because The USS importer makes heavy use of the AssetDatabase to resolve asset paths. To make the importer runtime-ready, the UI Toolkit needs to come up with other ways to resolve asset paths. So that you can change any style of your controls (during project creation in the editor) for any selector for example : Hover when the mouse is hovering over the control. This can be done before the final build and will work runtime, but we can't generate runtime a new style. CoDriven Advanced UI will build all styles and selectors for all you screens before final build so that you will be able to use it runtime normally, but you won't be able to generate styles runtime. You can of course change styles runtime by using fields from controls but not by USS code. Because of that the new version of CoDriven Advanced UI will propably depend only on dynamic code generation, but current version is enought - it works like UI Toolkit, so don't worry. So, we can: create styles for any visual look before build and set at runtime to change it dynamically runtime, create custom selectors and activate/deactivate it runtime (that will change the visual look and feel of control for certain conditions) dynamically change the visual of any control by accessing the stylesheet property of any CmControl.getVisualElement() .stylesheet. So we can for example dynamically load any image and change it runtime. Because of all of that - CoDriven Advanced UI has an additional custom selector that will allow you to execute runtime. So you want to make control half opacity and red in certain conditions runtime. You will create that style for it with your custom name and activate or deactivate that style runtime. Important!. The next version of the CoDriven Advanced UI will be probably fully based on dynamic changes without using CSS/USS so any dynamic changes runtime would be dynamic by default. Anyway - all the unity UI Toolkit selectors will work normally in runtime, so you will normally create a style for each selector you want. For example when the mouse is hovered, when control is disabled, or checked: var cmToggle = new CmToggle (..); cmToogle . modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other state using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . BorderWidth ( 0 ) . BorderRadius ( 60 . px ()) . BorderColorRGBA ( new Color32 ( 255 , 51 , 4 , 255 )) //Now add modifiers for HOVER state . ____NextSelector ( CmSelector . HOVER ) . Scale ( 1.2f ) //Now add modifiers for the DISABLED state . ____NextSelector ( CmSelector . DISABLED ) . BackgroundColorRGBA ( Color . white ) //Now add modifiers for the CHECKED state . ____NextSelector ( CmSelector . CHECKED ) . BackgroundColorRGBA ( Color . gray ) ); to learn more about changing visual look see theming , modifiers and controls","title":"Limitations of the current version of CoDriven Advanced UI:"},{"location":"index.html#codriven-advanced-ui-components","text":"","title":"CoDriven Advanced UI components"},{"location":"index.html#screen-manager-cmscreenmanager","text":"The main component of CoDriven Advanced UI is CmScreenManager which is a container for all screens and themes in your game. You can create many screen managers. For example: One for the main menu, and one for in-game. You Provide a list of * CmScreen * and a list of Themes CmThemeBase. Here you can handle global UI events by clicking on the buttons. To learn more about it click here","title":"Screen Manager (CmScreenManager)"},{"location":"index.html#screen-cmscreen","text":"This is a single screen visible as a whole on the monitor screen currently. The screen is tightly coupled with a theme. If you don't use a theme then you can create a screen based on the default theme. Here you can handle screen-related UI events like clicking on the buttons. To learn more about it click here","title":"Screen (CmScreen)"},{"location":"index.html#theme-icmthemebase","text":"The theme is just a base Interface inherited after ICmThemeBase which you will provide. It will contain methods like: public interface CmExample1ThemeBase : ICmThemeBase { public void StyleButton ( CmButton button ); } You will tell Screen Manager, or Screen that this interface will be used for theming, and create classes that will inherit this interface to actually style your control with the implemented method. So you can use the base interface when you create control and you won't worry about which theme is currently in use. You can have as many themes as you want and easily change theme runtime. To learn more about theming click here","title":"Theme (ICmThemeBase)"},{"location":"index.html#screen-part-cmscreenpart","text":"This is an optional element. It was added to divide the whole screen into sections. This way you can reuse certain sections on multiple screens. Like the game settings panel for changes in the main menu and in the game. This way it's more reusable. CmScreenPart is also usable to handle UI events (like button clicks or other events) and encapsulate this logic to this screen part. Of course, you can handle events in higher order parts of your system like CmScreen or * CmScreenManager * you can handle screen part-related UI events like clicking on the buttons. To learn more about CmScreenPart click here","title":"Screen Part (CmScreenPart)"},{"location":"index.html#controls","text":"CoDriven Advanced UI is an adapter for UI toolkit components with an extension. You can easily modify UI Toolkit controls as usual that are attached to adaptee control. but you can easily handle UI events and styling without needing the \"USS/CSS\" part. To see all available controls at the moment please click here","title":"Controls"},{"location":"index.html#modifiers","text":"Modifiers are properties that will change the look and feel of UI Toolkit controls like USS/CSS code, but they are managed in the code. Modifiers were divided into categories to make it more intuitive while modifying the control style. So for example you can have control with text that will have CmModifierBackground and more extensive modifier * CmModifierText for Text elements like labels. It doesn't make sense to use text modifiers on images. But * CmModifierText is an extension of CmModifierBackground** so you can use all properties from the background on the text element but you cannot use the text element on the background. CmModifierText - for styling elements with text, CmModifierBackground - for elements with background, CmModifierImageAndBackground - for images, CmModifierColumn and CmModifierRow - for column and row components, to get more information about modifiers click here","title":"Modifiers"},{"location":"index.html#ui-events","text":"UIEvents are mapped internally to simple Class. This way you can easily use events in any place of your elements tree. The whole menu is built onto CmScreenManager , and next CmScreen which is attached to CmScreenManager , and next CmScreenPart (optional) which is attached to CmScreen, and finally, CmControlBase which is added to CmScreenPart. So basically there is a relation like this CmScreenManager <- CmScreen <- CmScreenPart <- CmControl You can handle events the same way. The UI events are generated by CmControl. This event can be handled inside the function that creates CmControl, or upper in CmScreenPart or upper CmScreen, or globally in CmScreenManager. This way you can have a button \"Change theme to My favorite\" and handle click event (generated by this button) globally in CmScreenManager. This way you will not repeat code related to changing themes inside each visible screen. More about UI events here .","title":"UI events"},{"location":"index.html#tutorials","text":"CoDriven Advanced UI contains a few sample scenes but it will be better to read the tutorial section first (here)","title":"Tutorials"},{"location":"changelog.html","text":"CoDriven Advanced UI documentation Go back Changelog v1.1.1 03/04/2024 New: * added enemies to multiplayer game. Now there will be flying planes attacking you Improved: - reduced fire rate of flying enemies to improve fps Bugfix: * fixed big crosshair","title":"Change log"},{"location":"changelog.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"changelog.html#changelog","text":"","title":"Changelog"},{"location":"changelog.html#v111","text":"","title":"v1.1.1"},{"location":"changelog.html#03042024","text":"New: * added enemies to multiplayer game. Now there will be flying planes attacking you Improved: - reduced fire rate of flying enemies to improve fps Bugfix: * fixed big crosshair","title":"03/04/2024"},{"location":"cmlive_data.html","text":"CoDriven Advanced UI documentation Go back CmLiveData - observable field CmLiveData is for generic type observer. available methods: available methods are self-explanatory public void Observe ( Action < T > observer , DisposableObservers disposableObservers = null ) public void Remove ( Action < T > observer ) public void RemoveAllObservers () public bool HasObservers () DisposableObservers you can pass DisposableObservers to Observe() method to control lifecycle of observers and call dispose when you dont want to observe anymore private DisposableObservers disposableObservers = new DisposableObservers (); private CmLiveData < String > livedata = new CmLiveData < String > (); // ... livedata . Observe ( value => { // this is callback when that will be called when livedata string field change // do something with value }, disposableObservers ); // someware in the code livedata . value = \"new text\" ; // will trigger above callback \"livedata.Observe(value => {\" livedata . value = \"other text\" ; // will trigger above callback \"livedata.Observe(value => {\" // ... somewhere elese in the code // when you don't want observer anymore disposableObservers . dispose (); When you add multiple observers to CmLiveData which passing your disposableObservers, then you can remove all observers by using DisposableObservers.dispose() CmSingleObserverLiveData - observable field CmSingleObserverLiveData - observable field with only one observer available methods: available methods are self-explanatory public void Observe ( Action < T > observer ) public bool HasObservers ()","title":"Game settings util"},{"location":"cmlive_data.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"cmlive_data.html#cmlivedata-observable-field","text":"CmLiveData is for generic type observer. available methods: available methods are self-explanatory public void Observe ( Action < T > observer , DisposableObservers disposableObservers = null ) public void Remove ( Action < T > observer ) public void RemoveAllObservers () public bool HasObservers ()","title":"CmLiveData - observable field"},{"location":"cmlive_data.html#disposableobservers","text":"you can pass DisposableObservers to Observe() method to control lifecycle of observers and call dispose when you dont want to observe anymore private DisposableObservers disposableObservers = new DisposableObservers (); private CmLiveData < String > livedata = new CmLiveData < String > (); // ... livedata . Observe ( value => { // this is callback when that will be called when livedata string field change // do something with value }, disposableObservers ); // someware in the code livedata . value = \"new text\" ; // will trigger above callback \"livedata.Observe(value => {\" livedata . value = \"other text\" ; // will trigger above callback \"livedata.Observe(value => {\" // ... somewhere elese in the code // when you don't want observer anymore disposableObservers . dispose (); When you add multiple observers to CmLiveData which passing your disposableObservers, then you can remove all observers by using DisposableObservers.dispose()","title":"DisposableObservers"},{"location":"cmlive_data.html#cmsingleobserverlivedata-observable-field","text":"CmSingleObserverLiveData - observable field with only one observer available methods: available methods are self-explanatory public void Observe ( Action < T > observer ) public bool HasObservers ()","title":"CmSingleObserverLiveData - observable field"},{"location":"contact.html","text":"CoDriven Advanced UI documentation Go back Contact information you can ask questions in the discord server: Discord: More information and help you can find on youtube channel:","title":"Contact information"},{"location":"contact.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"contact.html#contact-information","text":"you can ask questions in the discord server: Discord: More information and help you can find on youtube channel:","title":"Contact information"},{"location":"graph_editor.html","text":"CoDriven Advanced UI documentation Go back","title":"Graph editor"},{"location":"graph_editor.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"modifiers.html","text":"CoDriven Advanced UI documentation Go back CoDriven Advanced UI documentation Introduction Modifiers builder Base modifiers Modifiers used by controls How it works all together with controls what is UssPropertyVal So, how to create these values? Custom modifiers (for your own visual change for control runtime) CmSelector (controls visual state) Simple list of all modifiers CmModifierBase modifiers CmModifierBaseBackground modifiers CmModifierBaseImageAndBackground modifiers CmModifierText modifiers CmModifierRow modifiers CmModifierColumn modifiers What next Introduction All controls have their modifiers. For example, CmScrollView has modifiers for the background and modifiers for vertical/horizontal scrollbars. We need to change different properties for text elements but for background elements, there are fewer properties available than for text. Because the text has font size/color etc. but the background does not. Modifiers builder This is why modifier builder - the class that we will be using for building style for specific control is divided into groups that inherit from other groups modifiers to build modifiers depend on their type like text, background etc. This is how it looks graph TD ; A[CmModifierBase] -- abstract class --> B[CmModifierBaseBackground]; B --> C[CmModifierBackground]; B --> D[CmModifierText]; B -- abstract class --> E[CmModifierBaseImageAndBackground]; B --> F[CmModifierColumn]; B --> G[CmModifierRow]; E --> H[CmModifierImageAndBackground]; Note: you shouldn't use classes with the text \" Base \" in their names from the above diagram. Only if you need to create your own class with your own modifiers that inherit from them. Base modifiers CmModifierBase - is the parent for all modifiers and contains generic modifiers. It will allow us to set properties like size, animation, padding, generic properties, border(color, radius, width), margin. CmModifierBaseBackground - extension from CmModifierBase . It will allow us to set properties like background: color, image, image tint color, image slice, scale mode, repeat, position, size CmModifierBaseImageAndBackground - extension from CmModifierBaseBackground . It will allow you to set properties like image, image scale mode, image tint color Modifiers used by controls CmModifierImageAndBackground - this is child of base modifer CmModifierBaseImageAndBackground . CmModifierBackground - this is child of base modifer CmModifierBaseBackground . CmModifierText - used where we need to change anything related to text. You can change properties like: text(color, outline color, size, font, alignment, outline width etc), multiline/single-line etc. CmModifierColumn is an extension for CmModifierBaseBackground that contains only two new methods: public CmModifierColumn HorizontalAlignment ( CmAlignment alignment ); public CmModifierColumn VerticalArrangement ( CmArrangement arrangement ); CmModifierRow is similar to CmModifierColumn and it is an extension for CmModifierBaseBackground that contains only two new methods: public CmModifierRow HorizontalArrangement ( CmArrangement arrangement ) public CmModifierRow VerticalAlignment ( CmAlignment alignment ) Note: As you can see CmModifierColumn has horizontalAlignment but CmModifierRow has HorizontalArrangement , the same difference is for vertical space. This is because the CmColumn is vertical container, but CmRow is a horizontal container. The same rules affect html/css controls. How it works all together with controls All controls have a field called Modifiers which is a class that allows you to style elements of these controls like background, label, scrollbars, etc. Some controls have many elements like CmScrollView. But for example, let's take a look at CmToogle control. This is simple toggle button. CmToogle has a Modifiers field that contains methods to style elements of CmToogle control like Background, Label, CheckMarkBackground and CheckMark public CmToggleModifiers Background ( CmModifierBackground modifier ) public CmToggleModifiers Label ( CmModifierText modifier ) public CmToggleModifiers CheckMarkBackground ( CmModifierBackground modifier ) public CmToggleModifiers CheckMark ( CmModifierImageAndBackground modifier ) so you can style any element of toggle control by using: var cmToggle = new CmToggle (..); var modifiers = cmToogle . Modifiers ; // change CheckMarkBackground modifiers . CheckMarkBackground (...) // change checkmark modifiers . CheckMark (...) // change Label modifiers . Label (...) Note: each method allows you to style other elements and because the label is not background it will use different Modifiers builder. Label contains text so it uses CmModifierText , but the Background is just a simple background, so text modifiers are useless here so we hide its methods by using a less extended modifier builder like * CmModifierBackground *. Here is how to style the checkmark element which contains the image and background so it uses CmModifierImageAndBackground modifier: var cmToggle = new CmToggle (..); cmToogle . Modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other states using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . BorderWidth ( 0 ) . BorderRadius ( 60 . px ()) . BorderColorRGBA ( new Color32 ( 255 , 51 , 4 , 255 )) //Now add modifiers for HOVER state . ____NextSelector ( CmSelector . HOVER ) . Scale ( 1.2f ) //Now add modifiers for the DISABLED state . ____NextSelector ( CmSelector . DISABLED ) . BackgroundColorRGBA ( Color . white ) //Now add modifiers for the CHECKED state . ____NextSelector ( CmSelector . CHECKED ) . BackgroundColorRGBA ( Color . gray ) ); This code can have multiple lines because you would want to change many modifiers, but it's simple to understand and easier to maintain than the USS code. Additionally, you will not have to know the class name for the toggle checkmark to change it and modifiers will hide difficult flex uss code behind simple API. what is UssPropertyVal Many modifiers allow you to set parameters as percents, pixels, or others. These modifiers will accept parameters with int type which will be converted to pixels internally in USS. There are also overloaded versions of these modifier functions that will accept parameters as UssPropertyVal . UssPropertyVal is a special conversion class generated automatically from your int/float/double parameters that will be converted to pixels/percents/other. Important: You won't have to create this class because it will be created automatically when you use the extension function on int/float/double values. So, how to create these values? here is an example of that cmToogle . Modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other state using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . BorderWidth ( 4 . px ()) ); in this example, BorderWidth accepts UssPropertyVal but it was automatically created from int value \"4\" converted by extension function \"px()\" to UssPropertyVal class you can use extension functions on base types int/float/double in some exceptions: extension function out class convert to .px() UssPropertyVal pixel values .percent() UssPropertyVal percentage values .em() UssPropertyVal font em values .rem() UssPropertyVal font rem values .deg() UssPropertyVal rotation values .rad() UssPropertyVal rotation values .grad() UssPropertyVal rotation values Another example. If you want to set font size using \"em()\" cmToogle . Modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other state using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . TextFontSize ( 12 . em ()) ); Custom modifiers (for your own visual change for control runtime) Suppose that for example, you want to hide a label using USS code for the UI toolkit using your custom modifier. var cmToggle = new CmToggle (..); //Create a custom selector for the label with the name: \"your_custom_selector_name_enter_here\" cmToogle . Modifiers . Label ( new CmModifierText ( CmSelector . DEFAULT_STATE , \"your_custom_selector_name_enter_here\" ) . Hide () ); //------------------------ // then runtime //Add your selector to hide the label cmToggle . SetCustomSelector ( \"your_custom_selector_name_enter_here\" ); // to remove your selector to show the label cmToggle . RemoveCustomSelector ( \"your_custom_selector_name_enter_here\" ); CmSelector (controls visual state) The selector is something like a state of control. Here is the list of states /// <summary> /// Use this to build a selecor for control. For example when you want to change style when the mouse is over a control. /// This is a pseudo Class Type of visual element eg. selector. /// </summary> public enum CmSelector { /// default style DEFAULT_STATE , /// The cursor is positioned over the element. HOVER , /// A user interacts with the element. Button click for example. ACTIVE , /// A user stops to interact with the element. INACTIVE , /// The element has focus. FOCUS , /// USS doesn\u2019t support this pseudo-state. Use :checked instead. SELECTED , /// The element is in a disabled state. DISABLED , /// The element is in an enabled state. ENABLED , /// The element is a Toggle or RadioButton element and it\u2019s selected. CHECKED , /// The element is the highest-level element in the visual tree ROOT } DEFAULT_STATE is the state when control is visible on the screen and nothing is changed with its state. You will always use this state for styling. Typically you will also style control for HOVER and DISABLED states to change how the control will look while the mouse is hovering over it, or when the control is disabled. Here is an example of how to style these three states: var cmToggle = new CmToggle (..); cmToogle . Modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other states using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . BorderWidth ( 0 ) . BorderRadius ( 60 . px ()) . BorderColorRGBA ( new Color32 ( 255 , 51 , 4 , 255 )) //Now add modifiers for HOVER state . ____NextSelector ( CmSelector . HOVER ) . Scale ( 1.2f ) //Now add modifiers for the DISABLED state . ____NextSelector ( CmSelector . DISABLED ) . BackgroundColorRGBA ( Color . white ) ); Simple list of all modifiers Here are all modifiers available in version 1.0.0 of CoDriven Advanced UI. Modifiers will be divided into sections based on the mentioned earlier ModifierBuilders CmModifierBase modifiers // left, top, right, bottom public T LeftInitial (); public T RightInitial (); public T TopInitial (); public T BottomInitial (); public T Left ( int left ); public T Left ( UssPropertyVal left ); public T Right ( int right ); public T Right ( UssPropertyVal right ); public T Top ( int top ); public T Top ( UssPropertyVal top ); public T Bottom ( int bottom ); public T Bottom ( UssPropertyVal bottom ); // size related public T Width ( int width ); public T Width ( UssPropertyVal width ); public T FillMaxWidth ( float factor ); public T WidthWrapContent (); public T WidthAuto (); public T FillParentWidth (); public T Height ( int height ); public T Height ( UssPropertyVal height ); public T FillMaxHeight ( float factor ); public T HeightWrapContent (); public T HeightAuto (); public T FillParentHeight (); public T Weight ( float weight = 1.0f ); // animation public T AnimEnable ( bool enable = true ); public T AnimDuration ( int durationMillisecond = 1 ); public T AnimDelay ( int delayMillisecond = 1 ); public T AnimEasing ( CmAnimationEasing cmAnimationEasing ); public T AnimEasingInitial (); public T AnimDelayInitial (); public T AnimDurationInitial (); public T AnimEnableInitial (); // pading public T PaddingAll ( UssPropertyVal left , UssPropertyVal top , UssPropertyVal right , UssPropertyVal bottom ); public T PaddingLeft ( UssPropertyVal left ); public T PaddingRight ( UssPropertyVal right ); public T PaddingTop ( UssPropertyVal top ); public T PaddingBottom ( UssPropertyVal bottom ); public T PaddingHorizVert ( UssPropertyVal horizontalPadding , UssPropertyVal verticalPadding ); public T PaddingAll ( int left , int top , int right , int bottom ); public T PaddingLeft ( int left ); public T PaddingRight ( int right ); public T PaddingTop ( int top ); public T PaddingBottom ( int bottom ); public T PaddingHorizVert ( int horizontalPadding , int verticalPadding ); // visibility public T Opacity ( float opacity = 1.0f ); public T Invisible (); public T Hide (); public T Show (); // position related to parent public T PositionRelativeToParent (); public T PositionAbsoluteInFirstRelativeParent (); public T FreeFloatingWorldSpace (); public T AttachToParent (); public T DetachFromAllParents (); // scale public T Scale ( int scale ); public T Scale ( UssPropertyVal scale ); public T Scale ( float scale ); public T Scale ( int x , int y ); public T Scale ( UssPropertyVal x , UssPropertyVal y ); public T Scale ( float x , float y ); // transform rotate/move/translate public T Rotate ( UssPropertyRotationVal angle ); public T Move ( UssPropertyVal tx , UssPropertyVal ty ); public T Translate ( UssPropertyVal tx , UssPropertyVal ty ); // orygin public T OriginCornerTopLeft (); public T OriginCornerTopRight (); public T OriginCornerBottomLeft (); public T OriginCornerBottomRight (); public T OriginAtCenterPoint (); public T OriginEdgeLeftCenter (); public T OriginEdgeTopCenter (); public T OriginEdgeRightCenter (); public T OriginEdgeBottomCenter (); public T OriginPoint ( UssPropertyVal tx , UssPropertyVal ty ); // overflow (it means clip/no clip children controls to not draw over parent borders) public T OverflowVisible (); public T OverflowHidden (); public T OverflowClip (); public T OverflowScroll (); public T AlignSelf ( CmAlignment alignment ); public T AlignSelfInitial (); // min max width/height public T MinWidthInitial (); public T MinHeightInitial (); public T MaxWidthInitial (); public T MaxHeightInitial (); public T MinWidth ( int minWidth ); public T MinWidth ( UssPropertyVal minWidth ); public T MinHeight ( int minHeight ); public T MinHeight ( UssPropertyVal minHeight ); public T MaxWidth ( int maxWidth ); public T MaxWidth ( UssPropertyVal maxWidth ); public T MaxHeight ( int maxHeight ); public T MaxHeight ( UssPropertyVal maxHeight ); // flex modifiers for more advanced usage similar to USS public T FlexShrinkInitial (); public T FlexGrowInitial (); public T FlexBasisInitial (); public T FlexShrink ( int shrink ); public T FlexShrink ( UssPropertyVal shrink ); public T FlexDontShrink (); public T FlexAllowShrink (); public T FlexGrow ( int grow ); public T FlexGrow ( UssPropertyVal grow ); public T FlexDontGrow (); public T FlexAllowGrow (); public T FlexBasis ( int basis ); public T FlexBasis ( UssPropertyVal basis ); public T FlexBasisAuto (); // border color public T BorderColorRGB ( Color color ); public T BorderColorRGBA ( Color color ); public T BorderColorHex ( string hexColor ); public T BorderColorRGBA ( Color32 color ); public T BorderColorRGB ( Color32 color ); public T BorderColorTransparent (); // border radius public T BorderRadius ( int radius ); public T BorderRadiusLeftTop ( int radius ); public T BorderRadiusLeftBottom ( int radius ); public T BorderRadiusRightTop ( int radius ); public T BorderRadiusRightBottom ( int radius ); public T BorderRadiusInitial (); public T BorderRadiusLeftTopInitial (); public T BorderRadiusLeftBottomInitial (); public T BorderRadiusRightTopInitial (); public T BorderRadiusRightBottomInitial (); public T BorderRadius ( UssPropertyVal radius ); public T BorderRadiusLeftTop ( UssPropertyVal radius ); public T BorderRadiusLeftBottom ( UssPropertyVal radius ); public T BorderRadiusRightTop ( UssPropertyVal radius ); public T BorderRadiusRightBottom ( UssPropertyVal radius ); // border width public T BorderWidth ( int borderWidth ); public T BorderWidthLeft ( int borderWidth ); public T BorderWidthBottom ( int borderWidth ); public T BorderWidthTop ( int borderWidth ); public T BorderWidthRight ( int borderWidth ); public T BorderWidth ( UssPropertyVal borderWidth ); public T BorderWidthLeft ( UssPropertyVal borderWidth ); public T BorderWidthBottom ( UssPropertyVal borderWidth ); public T BorderWidthTop ( UssPropertyVal borderWidth ); public T BorderWidthRight ( UssPropertyVal borderWidth ); // margin public T Margin ( UssPropertyVal margin ); public T MarginAll ( UssPropertyVal left , UssPropertyVal top , UssPropertyVal right , UssPropertyVal bottom ); public T MarginLeft ( UssPropertyVal left ); public T MarginRight ( UssPropertyVal right ); public T MarginTop ( UssPropertyVal top ); public T MarginBottom ( UssPropertyVal bottom ); public T MarginHorizVert ( UssPropertyVal horizontalMargin , UssPropertyVal verticalMargin ); public T Margin ( int margin ); public T MarginAll ( int left , int top , int right , int bottom ); public T MarginLeft ( int left ); public T MarginRight ( int right ); public T MarginTop ( int top ); public T MarginBottom ( int bottom ); public T MarginHorizVert ( int horizontalMargin , int verticalMargin ); public T MarginLeftInitial (); public T MarginRightInitial (); public T MarginTopInitial (); public T MarginBottomInitial (); CmModifierBaseBackground modifiers // background color public T BackgroundColorRGB ( Color color ); public T BackgroundColorRGBA ( Color color ); public T BackgroundColorHex ( string hexColor ); public T BackgroundColorRGBA ( Color32 color ); public T BackgroundColorRGB ( Color32 color ); public T BackgroundColorTransparent (); // background image public T BackgroundImageRes ( string path ); public T BackgroundImageUrl ( string path ); public T BackgroundIcon ( CmUnityIcons cmUnityIcons ); public T BackgroundImageInitial (); // background image tint color public T BackgroundImageTintRGB ( Color color ); public T BackgroundImageTintRGBA ( Color color ); public T BackgroundImageTintHex ( string colorHex ); public T BackgroundImageTintRGBA ( Color32 color ); public T BackgroundImageTintRGB ( Color32 color ); public T BackgroundImageTintTransparent (); // background image slice (for proper image scalling like 9 patch) public T BackgroundImageSliceLeft ( int sliceValue ); public T BackgroundImageSliceRight ( int sliceValue ); public T BackgroundImageSliceTop ( int sliceValue ); public T BackgroundImageSliceBottom ( int sliceValue ); public T BackgroundImageSliceScale ( int sliceScale ); public T BackgroundImageSliceScale ( UssPropertyVal sliceScale ); public T BackgroundImageSliceLeftInitial (); public T BackgroundImageSliceRightInitial (); public T BackgroundImageSliceTopInitial (); public T BackgroundImageSliceBottomInitial (); public T BackgroundImageSliceScaleInitial (); // background scale public T BackgroundScaleMode ( CmBackgroundScaleMode cmBackgroundScaleMode ); public T BackgroundScaleModeInitial (); // background repeat public T BackgroundRepeat ( CmBackgroundRepeat cmBackgroundRepeat ); // background position public T BackgroundPositionX ( CmBackgroundPosition positionX ); public T BackgroundPositionY ( CmBackgroundPosition positionY ); public T BackgroundPositionX ( int positionX ); public T BackgroundPositionY ( int positionY ); public T BackgroundPositionX ( UssPropertyVal positionX ); public T BackgroundPositionY ( UssPropertyVal positionY ); // background size public T BackgroundSize ( UssPropertyVal bgSize ); public T BackgroundSizeContainInArea (); public T BackgroundSizeCoverArea (); CmModifierBaseImageAndBackground modifiers // image public T ImageRes ( string path ); public T ImageUrl ( string path ); public T UnityIcon ( CmUnityIcons cmUnityIcons ); public T ImageInitial (); // image public T ImageScaleMode ( CmImageScaleMode cmImageScaleMode ); // image tint color public T ImageTintColorRGB ( Color color ); public T ImageTintColorRGBA ( Color color ); public T ImageTintColorHex ( string hexColor ); public T ImageTintColorRGBA ( Color32 color ); public T ImageTintColorRGB ( Color32 color ); public T ImageTintColorTransparent (); CmModifierText modifiers // text color in different formats public T TextColorRGB ( Color color ); public T TextColorRGBA ( Color color ); public T TextColorHex ( string hexColor ); public T TextColorRGBA ( Color32 color ); public T TextColorRGB ( Color32 color ); public T TextColorTransparent (); // text font style public T TextFontStyle ( CmFontStyle fontStyle ); // text font outline width public T TextOutlineWidth ( int w ); public T TextOutlineWidth ( UssPropertyVal w ); // text align public T TextAlign ( CmTextAlign cmTextAlign ); // text font size public T TextFontSize ( int value ); public T TextFontSize ( UssPropertyTextVal value ); public T TextFontSize ( CmFontSizeName fontSizeName ); // text overflow position public T TextOverflowPosition ( CmTextOverflowPosition cmTextOverflowPosition ); public T TextOverflowInitial (); // text font loading public T TextFontRes ( string path ); public T TextFontUrl ( string path ); public T TextFontInitial (); // text whitespaces public T TextWhiteSpace ( CmTextWhiteSpace textWhiteSpace ); // text singleline/multiline public T TextMultiline (); public T TextSingleLine (); // text outline public T TextOutlineColorRGB ( Color color ); public T TextOutlineColorRGBA ( Color color ); public T TextOutlineColorHex ( string hexColor ); public T TextOutlineColorRGBA ( Color32 color ); public T TextOutlineColorRGB ( Color32 color ); public T TextOutlineColorTransparent (); CmModifierRow modifiers // layout direction (shouldn't be used in CmRow control) public T LayoutDirection ( CmLayoutDirection layoutDirection ); // horizontal and vertical (this is inverted in CmModifierColumn) public T HorizontalArrangement ( CmArrangement arrangement ); public T VerticalAlignment ( CmAlignment alignment ); CmModifierColumn modifiers // layout direction (shouldn't be used in CmColumn control) public T LayoutDirection ( CmLayoutDirection layoutDirection ); // horizontal and vertical (this is inverted in CmModifierRow) public T HorizontalAlignment ( CmAlignment alignment ); public T VerticalArrangement ( CmArrangement arrangement ); What next Because documentation will be probably changing less frequently than code - the description for these modifiers was not pasted here. You will find documentation for specified modifiers inside the code comment for the modifier function. In the controls seciton there is styling applied to individual controls and their elements","title":"Modifiers"},{"location":"modifiers.html#codriven-advanced-ui-documentation","text":"Go back CoDriven Advanced UI documentation Introduction Modifiers builder Base modifiers Modifiers used by controls How it works all together with controls what is UssPropertyVal So, how to create these values? Custom modifiers (for your own visual change for control runtime) CmSelector (controls visual state) Simple list of all modifiers CmModifierBase modifiers CmModifierBaseBackground modifiers CmModifierBaseImageAndBackground modifiers CmModifierText modifiers CmModifierRow modifiers CmModifierColumn modifiers What next","title":"CoDriven Advanced UI documentation"},{"location":"modifiers.html#introduction","text":"All controls have their modifiers. For example, CmScrollView has modifiers for the background and modifiers for vertical/horizontal scrollbars. We need to change different properties for text elements but for background elements, there are fewer properties available than for text. Because the text has font size/color etc. but the background does not.","title":"Introduction"},{"location":"modifiers.html#modifiers-builder","text":"This is why modifier builder - the class that we will be using for building style for specific control is divided into groups that inherit from other groups modifiers to build modifiers depend on their type like text, background etc. This is how it looks graph TD ; A[CmModifierBase] -- abstract class --> B[CmModifierBaseBackground]; B --> C[CmModifierBackground]; B --> D[CmModifierText]; B -- abstract class --> E[CmModifierBaseImageAndBackground]; B --> F[CmModifierColumn]; B --> G[CmModifierRow]; E --> H[CmModifierImageAndBackground]; Note: you shouldn't use classes with the text \" Base \" in their names from the above diagram. Only if you need to create your own class with your own modifiers that inherit from them.","title":"Modifiers builder"},{"location":"modifiers.html#base-modifiers","text":"CmModifierBase - is the parent for all modifiers and contains generic modifiers. It will allow us to set properties like size, animation, padding, generic properties, border(color, radius, width), margin. CmModifierBaseBackground - extension from CmModifierBase . It will allow us to set properties like background: color, image, image tint color, image slice, scale mode, repeat, position, size CmModifierBaseImageAndBackground - extension from CmModifierBaseBackground . It will allow you to set properties like image, image scale mode, image tint color","title":"Base modifiers"},{"location":"modifiers.html#modifiers-used-by-controls","text":"CmModifierImageAndBackground - this is child of base modifer CmModifierBaseImageAndBackground . CmModifierBackground - this is child of base modifer CmModifierBaseBackground . CmModifierText - used where we need to change anything related to text. You can change properties like: text(color, outline color, size, font, alignment, outline width etc), multiline/single-line etc. CmModifierColumn is an extension for CmModifierBaseBackground that contains only two new methods: public CmModifierColumn HorizontalAlignment ( CmAlignment alignment ); public CmModifierColumn VerticalArrangement ( CmArrangement arrangement ); CmModifierRow is similar to CmModifierColumn and it is an extension for CmModifierBaseBackground that contains only two new methods: public CmModifierRow HorizontalArrangement ( CmArrangement arrangement ) public CmModifierRow VerticalAlignment ( CmAlignment alignment ) Note: As you can see CmModifierColumn has horizontalAlignment but CmModifierRow has HorizontalArrangement , the same difference is for vertical space. This is because the CmColumn is vertical container, but CmRow is a horizontal container. The same rules affect html/css controls.","title":"Modifiers used by controls"},{"location":"modifiers.html#how-it-works-all-together-with-controls","text":"All controls have a field called Modifiers which is a class that allows you to style elements of these controls like background, label, scrollbars, etc. Some controls have many elements like CmScrollView. But for example, let's take a look at CmToogle control. This is simple toggle button. CmToogle has a Modifiers field that contains methods to style elements of CmToogle control like Background, Label, CheckMarkBackground and CheckMark public CmToggleModifiers Background ( CmModifierBackground modifier ) public CmToggleModifiers Label ( CmModifierText modifier ) public CmToggleModifiers CheckMarkBackground ( CmModifierBackground modifier ) public CmToggleModifiers CheckMark ( CmModifierImageAndBackground modifier ) so you can style any element of toggle control by using: var cmToggle = new CmToggle (..); var modifiers = cmToogle . Modifiers ; // change CheckMarkBackground modifiers . CheckMarkBackground (...) // change checkmark modifiers . CheckMark (...) // change Label modifiers . Label (...) Note: each method allows you to style other elements and because the label is not background it will use different Modifiers builder. Label contains text so it uses CmModifierText , but the Background is just a simple background, so text modifiers are useless here so we hide its methods by using a less extended modifier builder like * CmModifierBackground *. Here is how to style the checkmark element which contains the image and background so it uses CmModifierImageAndBackground modifier: var cmToggle = new CmToggle (..); cmToogle . Modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other states using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . BorderWidth ( 0 ) . BorderRadius ( 60 . px ()) . BorderColorRGBA ( new Color32 ( 255 , 51 , 4 , 255 )) //Now add modifiers for HOVER state . ____NextSelector ( CmSelector . HOVER ) . Scale ( 1.2f ) //Now add modifiers for the DISABLED state . ____NextSelector ( CmSelector . DISABLED ) . BackgroundColorRGBA ( Color . white ) //Now add modifiers for the CHECKED state . ____NextSelector ( CmSelector . CHECKED ) . BackgroundColorRGBA ( Color . gray ) ); This code can have multiple lines because you would want to change many modifiers, but it's simple to understand and easier to maintain than the USS code. Additionally, you will not have to know the class name for the toggle checkmark to change it and modifiers will hide difficult flex uss code behind simple API.","title":"How it works all together with controls"},{"location":"modifiers.html#what-is-usspropertyval","text":"Many modifiers allow you to set parameters as percents, pixels, or others. These modifiers will accept parameters with int type which will be converted to pixels internally in USS. There are also overloaded versions of these modifier functions that will accept parameters as UssPropertyVal . UssPropertyVal is a special conversion class generated automatically from your int/float/double parameters that will be converted to pixels/percents/other. Important: You won't have to create this class because it will be created automatically when you use the extension function on int/float/double values.","title":"what is UssPropertyVal"},{"location":"modifiers.html#so-how-to-create-these-values","text":"here is an example of that cmToogle . Modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other state using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . BorderWidth ( 4 . px ()) ); in this example, BorderWidth accepts UssPropertyVal but it was automatically created from int value \"4\" converted by extension function \"px()\" to UssPropertyVal class you can use extension functions on base types int/float/double in some exceptions: extension function out class convert to .px() UssPropertyVal pixel values .percent() UssPropertyVal percentage values .em() UssPropertyVal font em values .rem() UssPropertyVal font rem values .deg() UssPropertyVal rotation values .rad() UssPropertyVal rotation values .grad() UssPropertyVal rotation values Another example. If you want to set font size using \"em()\" cmToogle . Modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other state using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . TextFontSize ( 12 . em ()) );","title":"So, how to create these values?"},{"location":"modifiers.html#custom-modifiers-for-your-own-visual-change-for-control-runtime","text":"Suppose that for example, you want to hide a label using USS code for the UI toolkit using your custom modifier. var cmToggle = new CmToggle (..); //Create a custom selector for the label with the name: \"your_custom_selector_name_enter_here\" cmToogle . Modifiers . Label ( new CmModifierText ( CmSelector . DEFAULT_STATE , \"your_custom_selector_name_enter_here\" ) . Hide () ); //------------------------ // then runtime //Add your selector to hide the label cmToggle . SetCustomSelector ( \"your_custom_selector_name_enter_here\" ); // to remove your selector to show the label cmToggle . RemoveCustomSelector ( \"your_custom_selector_name_enter_here\" );","title":"Custom modifiers (for your own visual change for control runtime)"},{"location":"modifiers.html#cmselector-controls-visual-state","text":"The selector is something like a state of control. Here is the list of states /// <summary> /// Use this to build a selecor for control. For example when you want to change style when the mouse is over a control. /// This is a pseudo Class Type of visual element eg. selector. /// </summary> public enum CmSelector { /// default style DEFAULT_STATE , /// The cursor is positioned over the element. HOVER , /// A user interacts with the element. Button click for example. ACTIVE , /// A user stops to interact with the element. INACTIVE , /// The element has focus. FOCUS , /// USS doesn\u2019t support this pseudo-state. Use :checked instead. SELECTED , /// The element is in a disabled state. DISABLED , /// The element is in an enabled state. ENABLED , /// The element is a Toggle or RadioButton element and it\u2019s selected. CHECKED , /// The element is the highest-level element in the visual tree ROOT } DEFAULT_STATE is the state when control is visible on the screen and nothing is changed with its state. You will always use this state for styling. Typically you will also style control for HOVER and DISABLED states to change how the control will look while the mouse is hovering over it, or when the control is disabled. Here is an example of how to style these three states: var cmToggle = new CmToggle (..); cmToogle . Modifiers . CheckMark ( // create modifier for DEFAULT_STATE but we will add other states using ____NextSelector new CmModifierImageAndBackground ( CmSelector . DEFAULT_STATE ) . BorderWidth ( 0 ) . BorderRadius ( 60 . px ()) . BorderColorRGBA ( new Color32 ( 255 , 51 , 4 , 255 )) //Now add modifiers for HOVER state . ____NextSelector ( CmSelector . HOVER ) . Scale ( 1.2f ) //Now add modifiers for the DISABLED state . ____NextSelector ( CmSelector . DISABLED ) . BackgroundColorRGBA ( Color . white ) );","title":"CmSelector (controls visual state)"},{"location":"modifiers.html#simple-list-of-all-modifiers","text":"Here are all modifiers available in version 1.0.0 of CoDriven Advanced UI. Modifiers will be divided into sections based on the mentioned earlier ModifierBuilders","title":"Simple list of all modifiers"},{"location":"modifiers.html#cmmodifierbase-modifiers","text":"// left, top, right, bottom public T LeftInitial (); public T RightInitial (); public T TopInitial (); public T BottomInitial (); public T Left ( int left ); public T Left ( UssPropertyVal left ); public T Right ( int right ); public T Right ( UssPropertyVal right ); public T Top ( int top ); public T Top ( UssPropertyVal top ); public T Bottom ( int bottom ); public T Bottom ( UssPropertyVal bottom ); // size related public T Width ( int width ); public T Width ( UssPropertyVal width ); public T FillMaxWidth ( float factor ); public T WidthWrapContent (); public T WidthAuto (); public T FillParentWidth (); public T Height ( int height ); public T Height ( UssPropertyVal height ); public T FillMaxHeight ( float factor ); public T HeightWrapContent (); public T HeightAuto (); public T FillParentHeight (); public T Weight ( float weight = 1.0f ); // animation public T AnimEnable ( bool enable = true ); public T AnimDuration ( int durationMillisecond = 1 ); public T AnimDelay ( int delayMillisecond = 1 ); public T AnimEasing ( CmAnimationEasing cmAnimationEasing ); public T AnimEasingInitial (); public T AnimDelayInitial (); public T AnimDurationInitial (); public T AnimEnableInitial (); // pading public T PaddingAll ( UssPropertyVal left , UssPropertyVal top , UssPropertyVal right , UssPropertyVal bottom ); public T PaddingLeft ( UssPropertyVal left ); public T PaddingRight ( UssPropertyVal right ); public T PaddingTop ( UssPropertyVal top ); public T PaddingBottom ( UssPropertyVal bottom ); public T PaddingHorizVert ( UssPropertyVal horizontalPadding , UssPropertyVal verticalPadding ); public T PaddingAll ( int left , int top , int right , int bottom ); public T PaddingLeft ( int left ); public T PaddingRight ( int right ); public T PaddingTop ( int top ); public T PaddingBottom ( int bottom ); public T PaddingHorizVert ( int horizontalPadding , int verticalPadding ); // visibility public T Opacity ( float opacity = 1.0f ); public T Invisible (); public T Hide (); public T Show (); // position related to parent public T PositionRelativeToParent (); public T PositionAbsoluteInFirstRelativeParent (); public T FreeFloatingWorldSpace (); public T AttachToParent (); public T DetachFromAllParents (); // scale public T Scale ( int scale ); public T Scale ( UssPropertyVal scale ); public T Scale ( float scale ); public T Scale ( int x , int y ); public T Scale ( UssPropertyVal x , UssPropertyVal y ); public T Scale ( float x , float y ); // transform rotate/move/translate public T Rotate ( UssPropertyRotationVal angle ); public T Move ( UssPropertyVal tx , UssPropertyVal ty ); public T Translate ( UssPropertyVal tx , UssPropertyVal ty ); // orygin public T OriginCornerTopLeft (); public T OriginCornerTopRight (); public T OriginCornerBottomLeft (); public T OriginCornerBottomRight (); public T OriginAtCenterPoint (); public T OriginEdgeLeftCenter (); public T OriginEdgeTopCenter (); public T OriginEdgeRightCenter (); public T OriginEdgeBottomCenter (); public T OriginPoint ( UssPropertyVal tx , UssPropertyVal ty ); // overflow (it means clip/no clip children controls to not draw over parent borders) public T OverflowVisible (); public T OverflowHidden (); public T OverflowClip (); public T OverflowScroll (); public T AlignSelf ( CmAlignment alignment ); public T AlignSelfInitial (); // min max width/height public T MinWidthInitial (); public T MinHeightInitial (); public T MaxWidthInitial (); public T MaxHeightInitial (); public T MinWidth ( int minWidth ); public T MinWidth ( UssPropertyVal minWidth ); public T MinHeight ( int minHeight ); public T MinHeight ( UssPropertyVal minHeight ); public T MaxWidth ( int maxWidth ); public T MaxWidth ( UssPropertyVal maxWidth ); public T MaxHeight ( int maxHeight ); public T MaxHeight ( UssPropertyVal maxHeight ); // flex modifiers for more advanced usage similar to USS public T FlexShrinkInitial (); public T FlexGrowInitial (); public T FlexBasisInitial (); public T FlexShrink ( int shrink ); public T FlexShrink ( UssPropertyVal shrink ); public T FlexDontShrink (); public T FlexAllowShrink (); public T FlexGrow ( int grow ); public T FlexGrow ( UssPropertyVal grow ); public T FlexDontGrow (); public T FlexAllowGrow (); public T FlexBasis ( int basis ); public T FlexBasis ( UssPropertyVal basis ); public T FlexBasisAuto (); // border color public T BorderColorRGB ( Color color ); public T BorderColorRGBA ( Color color ); public T BorderColorHex ( string hexColor ); public T BorderColorRGBA ( Color32 color ); public T BorderColorRGB ( Color32 color ); public T BorderColorTransparent (); // border radius public T BorderRadius ( int radius ); public T BorderRadiusLeftTop ( int radius ); public T BorderRadiusLeftBottom ( int radius ); public T BorderRadiusRightTop ( int radius ); public T BorderRadiusRightBottom ( int radius ); public T BorderRadiusInitial (); public T BorderRadiusLeftTopInitial (); public T BorderRadiusLeftBottomInitial (); public T BorderRadiusRightTopInitial (); public T BorderRadiusRightBottomInitial (); public T BorderRadius ( UssPropertyVal radius ); public T BorderRadiusLeftTop ( UssPropertyVal radius ); public T BorderRadiusLeftBottom ( UssPropertyVal radius ); public T BorderRadiusRightTop ( UssPropertyVal radius ); public T BorderRadiusRightBottom ( UssPropertyVal radius ); // border width public T BorderWidth ( int borderWidth ); public T BorderWidthLeft ( int borderWidth ); public T BorderWidthBottom ( int borderWidth ); public T BorderWidthTop ( int borderWidth ); public T BorderWidthRight ( int borderWidth ); public T BorderWidth ( UssPropertyVal borderWidth ); public T BorderWidthLeft ( UssPropertyVal borderWidth ); public T BorderWidthBottom ( UssPropertyVal borderWidth ); public T BorderWidthTop ( UssPropertyVal borderWidth ); public T BorderWidthRight ( UssPropertyVal borderWidth ); // margin public T Margin ( UssPropertyVal margin ); public T MarginAll ( UssPropertyVal left , UssPropertyVal top , UssPropertyVal right , UssPropertyVal bottom ); public T MarginLeft ( UssPropertyVal left ); public T MarginRight ( UssPropertyVal right ); public T MarginTop ( UssPropertyVal top ); public T MarginBottom ( UssPropertyVal bottom ); public T MarginHorizVert ( UssPropertyVal horizontalMargin , UssPropertyVal verticalMargin ); public T Margin ( int margin ); public T MarginAll ( int left , int top , int right , int bottom ); public T MarginLeft ( int left ); public T MarginRight ( int right ); public T MarginTop ( int top ); public T MarginBottom ( int bottom ); public T MarginHorizVert ( int horizontalMargin , int verticalMargin ); public T MarginLeftInitial (); public T MarginRightInitial (); public T MarginTopInitial (); public T MarginBottomInitial ();","title":"CmModifierBase modifiers"},{"location":"modifiers.html#cmmodifierbasebackground-modifiers","text":"// background color public T BackgroundColorRGB ( Color color ); public T BackgroundColorRGBA ( Color color ); public T BackgroundColorHex ( string hexColor ); public T BackgroundColorRGBA ( Color32 color ); public T BackgroundColorRGB ( Color32 color ); public T BackgroundColorTransparent (); // background image public T BackgroundImageRes ( string path ); public T BackgroundImageUrl ( string path ); public T BackgroundIcon ( CmUnityIcons cmUnityIcons ); public T BackgroundImageInitial (); // background image tint color public T BackgroundImageTintRGB ( Color color ); public T BackgroundImageTintRGBA ( Color color ); public T BackgroundImageTintHex ( string colorHex ); public T BackgroundImageTintRGBA ( Color32 color ); public T BackgroundImageTintRGB ( Color32 color ); public T BackgroundImageTintTransparent (); // background image slice (for proper image scalling like 9 patch) public T BackgroundImageSliceLeft ( int sliceValue ); public T BackgroundImageSliceRight ( int sliceValue ); public T BackgroundImageSliceTop ( int sliceValue ); public T BackgroundImageSliceBottom ( int sliceValue ); public T BackgroundImageSliceScale ( int sliceScale ); public T BackgroundImageSliceScale ( UssPropertyVal sliceScale ); public T BackgroundImageSliceLeftInitial (); public T BackgroundImageSliceRightInitial (); public T BackgroundImageSliceTopInitial (); public T BackgroundImageSliceBottomInitial (); public T BackgroundImageSliceScaleInitial (); // background scale public T BackgroundScaleMode ( CmBackgroundScaleMode cmBackgroundScaleMode ); public T BackgroundScaleModeInitial (); // background repeat public T BackgroundRepeat ( CmBackgroundRepeat cmBackgroundRepeat ); // background position public T BackgroundPositionX ( CmBackgroundPosition positionX ); public T BackgroundPositionY ( CmBackgroundPosition positionY ); public T BackgroundPositionX ( int positionX ); public T BackgroundPositionY ( int positionY ); public T BackgroundPositionX ( UssPropertyVal positionX ); public T BackgroundPositionY ( UssPropertyVal positionY ); // background size public T BackgroundSize ( UssPropertyVal bgSize ); public T BackgroundSizeContainInArea (); public T BackgroundSizeCoverArea ();","title":"CmModifierBaseBackground modifiers"},{"location":"modifiers.html#cmmodifierbaseimageandbackground-modifiers","text":"// image public T ImageRes ( string path ); public T ImageUrl ( string path ); public T UnityIcon ( CmUnityIcons cmUnityIcons ); public T ImageInitial (); // image public T ImageScaleMode ( CmImageScaleMode cmImageScaleMode ); // image tint color public T ImageTintColorRGB ( Color color ); public T ImageTintColorRGBA ( Color color ); public T ImageTintColorHex ( string hexColor ); public T ImageTintColorRGBA ( Color32 color ); public T ImageTintColorRGB ( Color32 color ); public T ImageTintColorTransparent ();","title":"CmModifierBaseImageAndBackground modifiers"},{"location":"modifiers.html#cmmodifiertext-modifiers","text":"// text color in different formats public T TextColorRGB ( Color color ); public T TextColorRGBA ( Color color ); public T TextColorHex ( string hexColor ); public T TextColorRGBA ( Color32 color ); public T TextColorRGB ( Color32 color ); public T TextColorTransparent (); // text font style public T TextFontStyle ( CmFontStyle fontStyle ); // text font outline width public T TextOutlineWidth ( int w ); public T TextOutlineWidth ( UssPropertyVal w ); // text align public T TextAlign ( CmTextAlign cmTextAlign ); // text font size public T TextFontSize ( int value ); public T TextFontSize ( UssPropertyTextVal value ); public T TextFontSize ( CmFontSizeName fontSizeName ); // text overflow position public T TextOverflowPosition ( CmTextOverflowPosition cmTextOverflowPosition ); public T TextOverflowInitial (); // text font loading public T TextFontRes ( string path ); public T TextFontUrl ( string path ); public T TextFontInitial (); // text whitespaces public T TextWhiteSpace ( CmTextWhiteSpace textWhiteSpace ); // text singleline/multiline public T TextMultiline (); public T TextSingleLine (); // text outline public T TextOutlineColorRGB ( Color color ); public T TextOutlineColorRGBA ( Color color ); public T TextOutlineColorHex ( string hexColor ); public T TextOutlineColorRGBA ( Color32 color ); public T TextOutlineColorRGB ( Color32 color ); public T TextOutlineColorTransparent ();","title":"CmModifierText modifiers"},{"location":"modifiers.html#cmmodifierrow-modifiers","text":"// layout direction (shouldn't be used in CmRow control) public T LayoutDirection ( CmLayoutDirection layoutDirection ); // horizontal and vertical (this is inverted in CmModifierColumn) public T HorizontalArrangement ( CmArrangement arrangement ); public T VerticalAlignment ( CmAlignment alignment );","title":"CmModifierRow modifiers"},{"location":"modifiers.html#cmmodifiercolumn-modifiers","text":"// layout direction (shouldn't be used in CmColumn control) public T LayoutDirection ( CmLayoutDirection layoutDirection ); // horizontal and vertical (this is inverted in CmModifierRow) public T HorizontalAlignment ( CmAlignment alignment ); public T VerticalArrangement ( CmArrangement arrangement );","title":"CmModifierColumn modifiers"},{"location":"modifiers.html#what-next","text":"Because documentation will be probably changing less frequently than code - the description for these modifiers was not pasted here. You will find documentation for specified modifiers inside the code comment for the modifier function. In the controls seciton there is styling applied to individual controls and their elements","title":"What next"},{"location":"multiplayer_game.html","text":"CoDriven Advanced UI documentation Go back Multiplayer Game With full menu sample and scenes CoDriven Advanced UI documentation Multiplayer Game With full menu sample and scenes Introduction Main menu scene (MainMenuScene.unity) MainMenuScreensManager Game Controls Introduction CoDriven Advanced UI is published with a fully working 3d multiplayer game using MIRROR/LAN (LAN because there is no ROOM/LOBBY/MATCH MAKING SERVICES. You can improve it by adding this functionality). The game itself is valuable, but the most important part of the game is the UI. UI in the game was fully created using CoDriven Advanced UI. The game is split into scenes. The game example is the most advanced of all other examples so please read the tutorial sections first here Main menu scene (MainMenuScene.unity) This scene is built mostly for Main Menu-related actions and settings. MainMenuScreensManager Scene i build upon the MainMenuScreensManager.cs. This is the core of the whole main menu. It contains 6 screens added in OnAddSupportedScreens and 4 themes added in OnAddSupportedThemes. OnBindUiEventsHandler is used to handle global-related actions like theme changing, or language. Open MainMenuScreensManager.cs for details. The MainMenuScreensManager is a container of: CmScreenMain.cs - the main menu panel with options like exit, about, settings, multiplayer almost all screens are built from CmScreenParts that can be reused to reduce code repetition. All classes that represent CmScrenPart is suffixed with \"Sp\" at the end of the class name. Here is how the main screen is built: public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { var mainMenuGP = new MainMenuPanelSp ( this ); var screen = new MainScreenContentSp ( this , mainMenuGP , null , null ); contentList . Add ( screen . MakeContent ()); } MainMenuPanelSp.cs is a Main menu panel on the left side of the screen with options like exit, settings, about, multiplayer and this container is added to MainScreenContentSp.cs which is the main container for up to three Menu panels (left, center, right), We only pass mainMenuGP to the left panel param of the MainScreenContentSp constructor. So center and right panels will be null. Finally, the whole container is added to the contentList This way all the things will be rendered on screen. To see how it works please see the code of MainScreenContentSp.cs ** and MainMenuPanelSp.cs** MainMenuPanelSp is mostly responsible for changing the current screen to about/settings/multiplayer etc. CmScreenAbout.cs - this is screen with game description. This panel is built in a similar way to CmScreenMainMenu. The MainScreenContentSp is filled with 2 panels: MainMenuPanelSp.cs on the left for options PanelAboutSp.cs on the center as about panel with game description. public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { var mainMenuGP = new MainMenuPanelSp ( this ); var mainMenuAboutSs = new PanelAboutSp ( this ); var screen = new MainScreenContentSp ( this , mainMenuGP , mainMenuAboutSs ); contentList . Add ( screen . MakeContent ()); } please open PanelAboutSp.cs to see how you can add a colored rich text CmScreenMapSelect.cs - this is screen with game description. This panel is built in a similar way to CmScreenMainMenu. The MainScreenContentSp is filled with 2 panels: MainMenuPanelSp.cs on the left for options as always :) MapSelectPanelSp.cs on the center as about panel with game description. public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { var mainMenuGP = new MainMenuPanelSp ( this ); var mapSelectPanelSp = new MapSelectPanelSp ( this ); var screen = new MainScreenContentSp ( this , mainMenuGP , mapSelectPanelSp , null ); contentList . Add ( screen . MakeContent ()); } these two panels are added to the main container MainScreenContentSp and finally to contentList to make it visible later Note: The MapSelectPanelSp.cs is an interesting part of this screen because it contains CmDraggableScrollView for screenshots from game maps. This control allows you to scroll and snap to the center of an image, and move between images with centering the current image in the center of the control. The content for this control is a list of CmImage controls representing map screenshots. Open the MapSelectPanelSp.cs class for more details CmScreenSettingsControls.cs - is a simple screen with key bindings for the game. This panel is built in a similar way to previous screens but contains three panels instead of two like before: MainMenuPanelSp.cs on the left for options MiddlePanelSettingsSp.cs on the center - panel with settings like audio, video, controls, etc. PanelSettingsControlsSp.cs on the right - panel with key bindings description and contains two sliders to change mouse sensitivity for camera movement during the game public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { var mainMenuGP = new MainMenuPanelSp ( this ); var settingsGp = new MiddlePanelSettingsSp ( this ); var controlsSp = new PanelSettingsControlsSp ( this ); var screen = new MainScreenContentSp ( this , mainMenuGP , settingsGp , controlsSp ); contentList . Add ( screen . MakeContent ()); } please open PanelSettingsControlsSp.cs to see how to change mouse sensitivity Game Controls During play, you can use a keyboard and mouse mouse: left button - shoot weapon mouse: right button - use grappling hook key: w - move forward key: s - move backward key: a - move left key: d - move right key: space - jump key: f - on/off flashlight key: w - move forward key: c - zoom when using a sniper weapon key: t - camera toggle key: 1,2,3,4 - change weapons key: E - join vehicle key: Q - leave vehicle","title":"Multiplayer game sample"},{"location":"multiplayer_game.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"multiplayer_game.html#multiplayer-game-with-full-menu-sample-and-scenes","text":"CoDriven Advanced UI documentation Multiplayer Game With full menu sample and scenes Introduction Main menu scene (MainMenuScene.unity) MainMenuScreensManager Game Controls","title":"Multiplayer Game With full menu sample and scenes"},{"location":"multiplayer_game.html#introduction","text":"CoDriven Advanced UI is published with a fully working 3d multiplayer game using MIRROR/LAN (LAN because there is no ROOM/LOBBY/MATCH MAKING SERVICES. You can improve it by adding this functionality). The game itself is valuable, but the most important part of the game is the UI. UI in the game was fully created using CoDriven Advanced UI. The game is split into scenes. The game example is the most advanced of all other examples so please read the tutorial sections first here","title":"Introduction"},{"location":"multiplayer_game.html#main-menu-scene-mainmenusceneunity","text":"This scene is built mostly for Main Menu-related actions and settings.","title":"Main menu scene (MainMenuScene.unity)"},{"location":"multiplayer_game.html#mainmenuscreensmanager","text":"Scene i build upon the MainMenuScreensManager.cs. This is the core of the whole main menu. It contains 6 screens added in OnAddSupportedScreens and 4 themes added in OnAddSupportedThemes. OnBindUiEventsHandler is used to handle global-related actions like theme changing, or language. Open MainMenuScreensManager.cs for details. The MainMenuScreensManager is a container of: CmScreenMain.cs - the main menu panel with options like exit, about, settings, multiplayer almost all screens are built from CmScreenParts that can be reused to reduce code repetition. All classes that represent CmScrenPart is suffixed with \"Sp\" at the end of the class name. Here is how the main screen is built: public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { var mainMenuGP = new MainMenuPanelSp ( this ); var screen = new MainScreenContentSp ( this , mainMenuGP , null , null ); contentList . Add ( screen . MakeContent ()); } MainMenuPanelSp.cs is a Main menu panel on the left side of the screen with options like exit, settings, about, multiplayer and this container is added to MainScreenContentSp.cs which is the main container for up to three Menu panels (left, center, right), We only pass mainMenuGP to the left panel param of the MainScreenContentSp constructor. So center and right panels will be null. Finally, the whole container is added to the contentList This way all the things will be rendered on screen. To see how it works please see the code of MainScreenContentSp.cs ** and MainMenuPanelSp.cs** MainMenuPanelSp is mostly responsible for changing the current screen to about/settings/multiplayer etc. CmScreenAbout.cs - this is screen with game description. This panel is built in a similar way to CmScreenMainMenu. The MainScreenContentSp is filled with 2 panels: MainMenuPanelSp.cs on the left for options PanelAboutSp.cs on the center as about panel with game description. public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { var mainMenuGP = new MainMenuPanelSp ( this ); var mainMenuAboutSs = new PanelAboutSp ( this ); var screen = new MainScreenContentSp ( this , mainMenuGP , mainMenuAboutSs ); contentList . Add ( screen . MakeContent ()); } please open PanelAboutSp.cs to see how you can add a colored rich text CmScreenMapSelect.cs - this is screen with game description. This panel is built in a similar way to CmScreenMainMenu. The MainScreenContentSp is filled with 2 panels: MainMenuPanelSp.cs on the left for options as always :) MapSelectPanelSp.cs on the center as about panel with game description. public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { var mainMenuGP = new MainMenuPanelSp ( this ); var mapSelectPanelSp = new MapSelectPanelSp ( this ); var screen = new MainScreenContentSp ( this , mainMenuGP , mapSelectPanelSp , null ); contentList . Add ( screen . MakeContent ()); } these two panels are added to the main container MainScreenContentSp and finally to contentList to make it visible later Note: The MapSelectPanelSp.cs is an interesting part of this screen because it contains CmDraggableScrollView for screenshots from game maps. This control allows you to scroll and snap to the center of an image, and move between images with centering the current image in the center of the control. The content for this control is a list of CmImage controls representing map screenshots. Open the MapSelectPanelSp.cs class for more details CmScreenSettingsControls.cs - is a simple screen with key bindings for the game. This panel is built in a similar way to previous screens but contains three panels instead of two like before: MainMenuPanelSp.cs on the left for options MiddlePanelSettingsSp.cs on the center - panel with settings like audio, video, controls, etc. PanelSettingsControlsSp.cs on the right - panel with key bindings description and contains two sliders to change mouse sensitivity for camera movement during the game public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { var mainMenuGP = new MainMenuPanelSp ( this ); var settingsGp = new MiddlePanelSettingsSp ( this ); var controlsSp = new PanelSettingsControlsSp ( this ); var screen = new MainScreenContentSp ( this , mainMenuGP , settingsGp , controlsSp ); contentList . Add ( screen . MakeContent ()); } please open PanelSettingsControlsSp.cs to see how to change mouse sensitivity","title":"MainMenuScreensManager"},{"location":"multiplayer_game.html#game-controls","text":"During play, you can use a keyboard and mouse mouse: left button - shoot weapon mouse: right button - use grappling hook key: w - move forward key: s - move backward key: a - move left key: d - move right key: space - jump key: f - on/off flashlight key: w - move forward key: c - zoom when using a sniper weapon key: t - camera toggle key: 1,2,3,4 - change weapons key: E - join vehicle key: Q - leave vehicle","title":"Game Controls"},{"location":"screen.html","text":"CoDriven Advanced UI documentation Go back CmScreen CoDriven Advanced UI documentation CmScreen Introduction How to use GetScreenName() bindUIEventsOnStart() OnMakeScreenContent(List contentList) the most important section Complete example of CmScreen implementation from \"One Theme scene example\" Introduction CmScreen is a screen container for controls. You can have multiple screens but you show only one screen at once. How to use NOTE: Before you will read about CmScreen please read about theming here and CmScreenManager which is a container for CmScreen here . To create your own CmScreen you will have to select if you will use a theme or not. NOTE: If you won't use the theme then you can pass the default builtin CmThemeDefault empty theme interface like in example below: // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class MyMainScreen : CmScreen < CmThemeDefault > { ... // needed constructor public MyMainScreen ( CmScreenManager < CmThemeDefault > parent = null , VisualElement root = null ) : base ( parent , root ) {} ... } But in the theming section of the documentation we created a base interface for theme IMyExampleTheme and two implementations of themes MyThemeWhite and MyThemeBlack : // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class MyMainScreen : CmScreen < IMyExampleTheme > { public static string MYMAIN_SCREEN_NAME = \"MyMainScreen\" ; // needed constructor public MyMainScreen ( CmScreenManager < IMyExampleTheme > parent = null , VisualElement root = null ) : base ( parent , root ) {} public override void bindUIEventsOnStart ( CmUIEventsHandler eventsHandler ) { // handle events here } public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { //Add content to the list contentList . Add (... create content here ...); } public override string GetScreenName () { // return screen name. Screen name is useful for further screen changing in game/menu return MYMAIN_SCREEN_NAME ; } } As you can see adding a screen is nothing difficult. GetScreenName() We need to override GetScreenName () to return the screen name string (you can use an enum with the names of your screens and cast enum to string here) bindUIEventsOnStart() If you read the section about ScreenManager which I will suggest doing first then you will notice method * bindUIEventsOnStart *(). On CmScreenManager this method was for handling global UI events but here we handle events more local because it will be connected with this screen. This way we can handle events here and in CmScreenManager if you want. More about events see the ui_events section here OnMakeScreenContent(List contentList) the most important section content of the screen needs to be filled with controls. OnMakeScreenContent () function is just for that purpose. Below will be added a full working example from example projects that will show you how to create a simple screen with a button You can create any control extended from CmControl in OnMakeScreenContent and add it to contentList. You can also split your game menu into sections and each section could be CmScreenPart which is a part of the main menu see here . You can use this screenPart inside multiple screens. For example to create a simple static header which is the same on a few screens. so you will fulfill the known pattern \"don't repeat yourself (DRY)\" Complete example of CmScreen implementation from \"One Theme scene example\" /// <summary> /// This is a simple main screen that extends CmScreen but you have to tell us that you will be using CmExample1ThemeBase /// as the base theme for this screen, so we will know that all themes extended from CmExample1ThemeBase will be compatible /// for styling controls /// </summary> public class CmExample1MainScreen : CmScreen < CmExample1ThemeBase > { public static string MAIN_SCREEN_NAME = \"Example1MainScreen\" ; /// <summary> /// button names (could be enums but finally should be converted to a string to set the name of control) /// </summary> private const string MainButtonName = \"MyButtonName\" ; public CmExample1MainScreen ( CmScreenManager < CmExample1ThemeBase > parent = null , VisualElement root = null ) : base ( parent , root ) { } public override void bindUIEventsOnStart ( CmUIEventsHandler eventsHandler ) { // handle clicks for all buttons on this screen eventsHandler . ButtonClick = button => { //Check if the user clicked mainButton if ( button . GetName (). Equals ( MainButtonName )) { // handle on click for the main button } }; } public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { contentList . Add ( createMainPanel ()); } private CmColumn createMainPanel () { //Add column container and set vertical and horizontal position for all controls that will be added to it to the center //They will be on the screen center //Set background color for this column and make it fullscreen by setting Weight(1) - see modifiers section for more details var column = new CmColumn (); column . Modifiers . Column ( new CmModifierColumn ( CmSelector . DEFAULT_STATE ) . VerticalArrangement ( CmArrangement . CENTER ) . HorizontalAlignment ( CmAlignment . CENTER ) . BackgroundColorRGBA ( new Color ( 0 , 0 , 1 , 0.5f )) . Weight ( 1 ) ); //Create button with text and name (name will be used in the event handler to recognize events from this control) var button = createMainButton ( \"My main button (hello world button :)\" , MainButtonName ); //Add button to column column . AddContent ( button ); return column ; } public CmButton createMainButton ( string text , string name ) { //Create a simple button with text and UI event handler from this screen to handle events in this screen var button = new CmButton ( text , cmUIEventsHandler : GetCmUiEventsHandler ()); //Set button name for further event handling button . SetName ( name ); //Get the theme assigned to this screen and use its function to style this button GetTheme (). StyleButton ( button ); return button ; } public override string GetScreenName () { // return the screen name for this screen. Screen name is useful for further screen changing in-game/menu return MAIN_SCREEN_NAME ; } }","title":"Screen"},{"location":"screen.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"screen.html#cmscreen","text":"CoDriven Advanced UI documentation CmScreen Introduction How to use GetScreenName() bindUIEventsOnStart() OnMakeScreenContent(List contentList) the most important section Complete example of CmScreen implementation from \"One Theme scene example\"","title":"CmScreen"},{"location":"screen.html#introduction","text":"CmScreen is a screen container for controls. You can have multiple screens but you show only one screen at once.","title":"Introduction"},{"location":"screen.html#how-to-use","text":"NOTE: Before you will read about CmScreen please read about theming here and CmScreenManager which is a container for CmScreen here . To create your own CmScreen you will have to select if you will use a theme or not. NOTE: If you won't use the theme then you can pass the default builtin CmThemeDefault empty theme interface like in example below: // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class MyMainScreen : CmScreen < CmThemeDefault > { ... // needed constructor public MyMainScreen ( CmScreenManager < CmThemeDefault > parent = null , VisualElement root = null ) : base ( parent , root ) {} ... } But in the theming section of the documentation we created a base interface for theme IMyExampleTheme and two implementations of themes MyThemeWhite and MyThemeBlack : // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class MyMainScreen : CmScreen < IMyExampleTheme > { public static string MYMAIN_SCREEN_NAME = \"MyMainScreen\" ; // needed constructor public MyMainScreen ( CmScreenManager < IMyExampleTheme > parent = null , VisualElement root = null ) : base ( parent , root ) {} public override void bindUIEventsOnStart ( CmUIEventsHandler eventsHandler ) { // handle events here } public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { //Add content to the list contentList . Add (... create content here ...); } public override string GetScreenName () { // return screen name. Screen name is useful for further screen changing in game/menu return MYMAIN_SCREEN_NAME ; } } As you can see adding a screen is nothing difficult.","title":"How to use"},{"location":"screen.html#getscreenname","text":"We need to override GetScreenName () to return the screen name string (you can use an enum with the names of your screens and cast enum to string here)","title":"GetScreenName()"},{"location":"screen.html#binduieventsonstart","text":"If you read the section about ScreenManager which I will suggest doing first then you will notice method * bindUIEventsOnStart *(). On CmScreenManager this method was for handling global UI events but here we handle events more local because it will be connected with this screen. This way we can handle events here and in CmScreenManager if you want. More about events see the ui_events section here","title":"bindUIEventsOnStart()"},{"location":"screen.html#onmakescreencontentlist-contentlist-the-most-important-section","text":"content of the screen needs to be filled with controls. OnMakeScreenContent () function is just for that purpose. Below will be added a full working example from example projects that will show you how to create a simple screen with a button You can create any control extended from CmControl in OnMakeScreenContent and add it to contentList. You can also split your game menu into sections and each section could be CmScreenPart which is a part of the main menu see here . You can use this screenPart inside multiple screens. For example to create a simple static header which is the same on a few screens. so you will fulfill the known pattern \"don't repeat yourself (DRY)\"","title":"OnMakeScreenContent(List contentList) the most important section"},{"location":"screen.html#complete-example-of-cmscreen-implementation-from-one-theme-scene-example","text":"/// <summary> /// This is a simple main screen that extends CmScreen but you have to tell us that you will be using CmExample1ThemeBase /// as the base theme for this screen, so we will know that all themes extended from CmExample1ThemeBase will be compatible /// for styling controls /// </summary> public class CmExample1MainScreen : CmScreen < CmExample1ThemeBase > { public static string MAIN_SCREEN_NAME = \"Example1MainScreen\" ; /// <summary> /// button names (could be enums but finally should be converted to a string to set the name of control) /// </summary> private const string MainButtonName = \"MyButtonName\" ; public CmExample1MainScreen ( CmScreenManager < CmExample1ThemeBase > parent = null , VisualElement root = null ) : base ( parent , root ) { } public override void bindUIEventsOnStart ( CmUIEventsHandler eventsHandler ) { // handle clicks for all buttons on this screen eventsHandler . ButtonClick = button => { //Check if the user clicked mainButton if ( button . GetName (). Equals ( MainButtonName )) { // handle on click for the main button } }; } public override void OnMakeScreenContent ( List < CmControlBase > contentList ) { contentList . Add ( createMainPanel ()); } private CmColumn createMainPanel () { //Add column container and set vertical and horizontal position for all controls that will be added to it to the center //They will be on the screen center //Set background color for this column and make it fullscreen by setting Weight(1) - see modifiers section for more details var column = new CmColumn (); column . Modifiers . Column ( new CmModifierColumn ( CmSelector . DEFAULT_STATE ) . VerticalArrangement ( CmArrangement . CENTER ) . HorizontalAlignment ( CmAlignment . CENTER ) . BackgroundColorRGBA ( new Color ( 0 , 0 , 1 , 0.5f )) . Weight ( 1 ) ); //Create button with text and name (name will be used in the event handler to recognize events from this control) var button = createMainButton ( \"My main button (hello world button :)\" , MainButtonName ); //Add button to column column . AddContent ( button ); return column ; } public CmButton createMainButton ( string text , string name ) { //Create a simple button with text and UI event handler from this screen to handle events in this screen var button = new CmButton ( text , cmUIEventsHandler : GetCmUiEventsHandler ()); //Set button name for further event handling button . SetName ( name ); //Get the theme assigned to this screen and use its function to style this button GetTheme (). StyleButton ( button ); return button ; } public override string GetScreenName () { // return the screen name for this screen. Screen name is useful for further screen changing in-game/menu return MAIN_SCREEN_NAME ; } }","title":"Complete example of CmScreen implementation from \"One Theme scene example\""},{"location":"screen_manager.html","text":"CoDriven Advanced UI documentation Go back CoDriven Advanced UI documentation Introduction How to use Other functionality Complete example Introduction CmScreenManager is the main container of screens. You can have multiple screen managers. When you have multiple screen managers in one scene then you should show only one screen manager at once. How to use NOTE: Before you will read about screen managers please read about theming here . To create your own CmScreenManager you will have to select if you will use theme or not. NOTE: If you won't use the theme then you can pass the default builtin CmThemeDefault empty theme interface like in example below: // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class MyScreenManager : CmScreenManager < CmThemeDefault > { ... public override void OnAddSupportedScreens ( List < CmScreen < CmThemeDefault >> supportedScreenList ) {} public override void OnAddSupportedThemes ( List < CmThemeDefault > supportedThemes ) {} ... } But in the theming section of the documentation we created a base interface for theme IMyExampleTheme and two implementations of themes MyThemeWhite and MyThemeBlack so let's use it here: // IMyExampleTheme will be used as a base theme public class MyScreenManager : CmScreenManager < IMyExampleTheme > { public override void OnBindUiEventsHandler ( CmUIEventsHandler eventsHandler ) { // handle global actions on UI like clicks and other eventsHandler . ButtonClick = button => { // check globally if the user clicked the button, recognize the button by its name if ( button . GetName (). Equals ( \"here_will_be_your_button_name_to_check_for\" )) { //Here you will do some actions } }; } public override void OnAddSupportedScreens ( List < CmScreen < IMyExampleTheme >> supportedScreens ) { //Here you will add all your screens for this screen manager, and you will be able to change screen runtime supportedScreens . Add ( new MyMainScreen ( this )); } public override void OnAddSupportedThemes ( List < IMyExampleTheme > theme ) { //Add all your themes here for this screen manager themes . Add ( new MyThemeWhite ()); themes . Add ( new MyThemeBlack ()); } public override void OnSetMainScreen () { //You can set the main screen here at the start if you have multiple screens. by default main screen is the first Screen //All screens have their names as strings so you can create your screens as ENUM names and pass it here so there // will be no magic strings :) SetCurrentScreen ( \"ScreenMain\" ); } } As you can see, your themes were added in OnAddSupportedThemes function. So the system will know how to style controls. and you can change the theme anytime runtime using: SetCurrentTheme ( new MyThemeBlack ()); the SetCurrentTheme is available in your CmScreenManager, CmScreen, CmScreenPart Definition: public void SetCurrentTheme ( THEME originalTheme , bool rebuildControlsWithNewTheme = false ) rebuildControlsWithNewTheme parameter is used to rebuild the whole screen when you change the theme Other functionality MyScreenManager from the above example has also functions like: OnBindUiEventsHandler() - responsible for handling UI events generated by controls created inside screens. Because these controls were created inside you will handle their events inside screens but sometimes you will have to handle events globally. To reduce code duplication on multiple screens you could handle this event here. More about events see the ui_events section here , OnAddSupportedScreens() - here you will add all your screen instances for this screen manager. You will be able to use setCurrentScreen to switch screen runtime. public virtual void SetCurrentScreen ( string currentScreenName , bool makeContent = true ) this function is available in CmScreenManager, CmScreen, CmScreenPart OnSetMainScreen () - is called by the system on start so you can set the main screen here. NOTE : If you won't set the screen here then the first screen from OnAddSupportedScreens() will be used CmScreenManager has more functionality. Here is a more complete overview: MakeScreenContent () - you will use it to rebuild the whole screen (if you want to refresh the screen) UIDocument GetUIDocument () - you can get the current bound UIDocument List\\<string> GetScreensNames () - will return names of all screens added to this CmScreenManager HideMenu () - will deactivate UI to hide CmScreenManager from the screen. So there will be no screens visible ShowMenu(string currentScreenName) - will activate UI to show CmScreenManager on screen. When you show the screen the manager you will have to tell the system which Screen to show by passing currentScreenName parameter SetUserData(Object data) - while in the game you can pass your own data as an object to data parameter. // in your monobehaviour - somewhere in your player game logic public void UpdateUI () { if ( _screensManager == null ) { _screensManager = CmScreenManagerHelper . FindScreenManager (); } _screensManager . SetUserData ( someUserData ); } This data change will trigger callback OnUserDataChange for your active screen (CmScreen and other components like CmScreenPart) public virtual void OnUserDataChange ( Object data ) so you can update UI state there public class PlayerInGameScreen : CmScreenPart < IMyExampleTheme > { ... public override void OnUserDataChange ( Object data ) { if ( data is PlayerData playerData ) { _userName . SetText ( playerData . UserName ); _healtBar . SetProgress ( playerData . Health ); } } } Complete example here is a complete example of CmScreenManager implementation from \"One Theme scene example\" public class CmExample2ThemesScreenManager : CmScreenManager < ICmExample2ThemesBase > { public override void OnBindUiEventsHandler ( CmUIEventsHandler eventsHandler ) { // handle global actions on UI like clicks and other eventsHandler . ButtonClick = @base => { }; } public override void OnAddSupportedScreens ( List < CmScreen < ICmExample2ThemesBase >> supportedScreenList ) { //Add all screens here for this screen manager supportedScreenList . Add ( new CmSimpleThemeMainScreen ( this )); } public override void OnAddSupportedThemes ( List < ICmExample2ThemesBase > themeBases ) { //Add all themes here for this screen manager themeBases . Add ( new CmExample2ThemeOne ()); themeBases . Add ( new CmExample2ThemeTwo ()); } public override void OnSetMainScreen () { //You can set the main screen here at the start if you have multiple screens. by default main screen is the first Screen // added to supportedScreenList in above OnAddSupportedScreens(..) function SetCurrentScreen ( CmSimpleThemeMainScreen . MAIN_SCREEN_NAME ); } }","title":"Screen Manager"},{"location":"screen_manager.html#codriven-advanced-ui-documentation","text":"Go back CoDriven Advanced UI documentation Introduction How to use Other functionality Complete example","title":"CoDriven Advanced UI documentation"},{"location":"screen_manager.html#introduction","text":"CmScreenManager is the main container of screens. You can have multiple screen managers. When you have multiple screen managers in one scene then you should show only one screen manager at once.","title":"Introduction"},{"location":"screen_manager.html#how-to-use","text":"NOTE: Before you will read about screen managers please read about theming here . To create your own CmScreenManager you will have to select if you will use theme or not. NOTE: If you won't use the theme then you can pass the default builtin CmThemeDefault empty theme interface like in example below: // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class MyScreenManager : CmScreenManager < CmThemeDefault > { ... public override void OnAddSupportedScreens ( List < CmScreen < CmThemeDefault >> supportedScreenList ) {} public override void OnAddSupportedThemes ( List < CmThemeDefault > supportedThemes ) {} ... } But in the theming section of the documentation we created a base interface for theme IMyExampleTheme and two implementations of themes MyThemeWhite and MyThemeBlack so let's use it here: // IMyExampleTheme will be used as a base theme public class MyScreenManager : CmScreenManager < IMyExampleTheme > { public override void OnBindUiEventsHandler ( CmUIEventsHandler eventsHandler ) { // handle global actions on UI like clicks and other eventsHandler . ButtonClick = button => { // check globally if the user clicked the button, recognize the button by its name if ( button . GetName (). Equals ( \"here_will_be_your_button_name_to_check_for\" )) { //Here you will do some actions } }; } public override void OnAddSupportedScreens ( List < CmScreen < IMyExampleTheme >> supportedScreens ) { //Here you will add all your screens for this screen manager, and you will be able to change screen runtime supportedScreens . Add ( new MyMainScreen ( this )); } public override void OnAddSupportedThemes ( List < IMyExampleTheme > theme ) { //Add all your themes here for this screen manager themes . Add ( new MyThemeWhite ()); themes . Add ( new MyThemeBlack ()); } public override void OnSetMainScreen () { //You can set the main screen here at the start if you have multiple screens. by default main screen is the first Screen //All screens have their names as strings so you can create your screens as ENUM names and pass it here so there // will be no magic strings :) SetCurrentScreen ( \"ScreenMain\" ); } } As you can see, your themes were added in OnAddSupportedThemes function. So the system will know how to style controls. and you can change the theme anytime runtime using: SetCurrentTheme ( new MyThemeBlack ()); the SetCurrentTheme is available in your CmScreenManager, CmScreen, CmScreenPart Definition: public void SetCurrentTheme ( THEME originalTheme , bool rebuildControlsWithNewTheme = false ) rebuildControlsWithNewTheme parameter is used to rebuild the whole screen when you change the theme","title":"How to use"},{"location":"screen_manager.html#other-functionality","text":"MyScreenManager from the above example has also functions like: OnBindUiEventsHandler() - responsible for handling UI events generated by controls created inside screens. Because these controls were created inside you will handle their events inside screens but sometimes you will have to handle events globally. To reduce code duplication on multiple screens you could handle this event here. More about events see the ui_events section here , OnAddSupportedScreens() - here you will add all your screen instances for this screen manager. You will be able to use setCurrentScreen to switch screen runtime. public virtual void SetCurrentScreen ( string currentScreenName , bool makeContent = true ) this function is available in CmScreenManager, CmScreen, CmScreenPart OnSetMainScreen () - is called by the system on start so you can set the main screen here. NOTE : If you won't set the screen here then the first screen from OnAddSupportedScreens() will be used CmScreenManager has more functionality. Here is a more complete overview: MakeScreenContent () - you will use it to rebuild the whole screen (if you want to refresh the screen) UIDocument GetUIDocument () - you can get the current bound UIDocument List\\<string> GetScreensNames () - will return names of all screens added to this CmScreenManager HideMenu () - will deactivate UI to hide CmScreenManager from the screen. So there will be no screens visible ShowMenu(string currentScreenName) - will activate UI to show CmScreenManager on screen. When you show the screen the manager you will have to tell the system which Screen to show by passing currentScreenName parameter SetUserData(Object data) - while in the game you can pass your own data as an object to data parameter. // in your monobehaviour - somewhere in your player game logic public void UpdateUI () { if ( _screensManager == null ) { _screensManager = CmScreenManagerHelper . FindScreenManager (); } _screensManager . SetUserData ( someUserData ); } This data change will trigger callback OnUserDataChange for your active screen (CmScreen and other components like CmScreenPart) public virtual void OnUserDataChange ( Object data ) so you can update UI state there public class PlayerInGameScreen : CmScreenPart < IMyExampleTheme > { ... public override void OnUserDataChange ( Object data ) { if ( data is PlayerData playerData ) { _userName . SetText ( playerData . UserName ); _healtBar . SetProgress ( playerData . Health ); } } }","title":"Other functionality"},{"location":"screen_manager.html#complete-example","text":"here is a complete example of CmScreenManager implementation from \"One Theme scene example\" public class CmExample2ThemesScreenManager : CmScreenManager < ICmExample2ThemesBase > { public override void OnBindUiEventsHandler ( CmUIEventsHandler eventsHandler ) { // handle global actions on UI like clicks and other eventsHandler . ButtonClick = @base => { }; } public override void OnAddSupportedScreens ( List < CmScreen < ICmExample2ThemesBase >> supportedScreenList ) { //Add all screens here for this screen manager supportedScreenList . Add ( new CmSimpleThemeMainScreen ( this )); } public override void OnAddSupportedThemes ( List < ICmExample2ThemesBase > themeBases ) { //Add all themes here for this screen manager themeBases . Add ( new CmExample2ThemeOne ()); themeBases . Add ( new CmExample2ThemeTwo ()); } public override void OnSetMainScreen () { //You can set the main screen here at the start if you have multiple screens. by default main screen is the first Screen // added to supportedScreenList in above OnAddSupportedScreens(..) function SetCurrentScreen ( CmSimpleThemeMainScreen . MAIN_SCREEN_NAME ); } }","title":"Complete example"},{"location":"screen_part.html","text":"CoDriven Advanced UI documentation Go back Introduction CmScreenPart is a part of the screen container for controls. This is an optional component. You can add controls to screens directly, but this separation of concerns will help you manage larger projects and reuse parts of your screen UI. You can have multiple CmScreenPart added to CmScreen . How to use NOTE: Before you will read about CmScreenPart please read about theming here , CmScreenManager here and CmScreen here . This way you will understand how it's working all-together To create your own CmScreenPart you will have to select if you will use theme or not. NOTE: If you won't use the theme then you can pass the default builtin CmThemeDefault empty theme interface like in example below: // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class MyMainScreen : CmScreen < CmThemeDefault > { ... // needed constructor public MyMainScreen ( CmScreenManager < CmThemeDefault > parent = null , VisualElement root = null ) : base ( parent , root ) {} ... } But in the theming section of the documentation we created a base interface for theme IMyExampleTheme and two implementations of themes MyThemeWhite and MyThemeBlack : So let's use this here. This is how it would look like // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class CmScreenPartTopSectionExampleSP : CmScreenPart < IMyExampleTheme > { public CmScreenPartTopSectionExampleSP ( CmScreen < IMyExampleTheme > screen ) : base ( screen ) { } public override void BindUIEventsOnStart ( CmUIEventsHandler eventsHandler ) { } public override CmControlBase MakeContent () { var row = new CmRow (); GetTheme (). StyleScreenPartContentRow ( row ); row . AddContent ( OptionButton ( \"Theme1\" , \"Theme1\" )); row . AddContent ( OptionButton ( \"Theme2\" , \"Theme2\" )); return row ; } public CmButton OptionButton ( string text , string name ) { var button = new CmButton ( text , cmUIEventsHandler : getUIEventsHandler ()); button . SetName ( name ); GetTheme (). StyleButton ( button ); return button ; } } This is a simple screen part that could be reused on screens. MakeContent() The screen part is not CmControl. So when you want to add it to the screen you need to create content with controls from this screen part. That is why there is a method MakeContent () which will return some control or container with controls. In the above example, the content is built with a CmRow control container with two CmButtons added. To learn more about controls see there BindUIEventsOnStart() Here BindUIEventsOnStart () function is the same as in CmScreenManager, CmScreen but you can handle UI event whenever you want. CmScreenPart is the lowest place where you can handle events. Events will go up and will be handled in such direction : graph LR A[CmScreenPart.OnClick] --> B[CmScreen.OnClick] B --> C[CmScreenManager.OnClick] So you can handle events whenever you want. Note: when you create control you will pass CmUIEventsHandler as a parameter. You will have to pass CmUiEventHandler for current CmScreenPart by using the method of CmScreenPart.getUIEventsHandler(). This way events will be propagated upper in the view hierarchy like in the above diagram. If you create your event handler and pass it or null, then CmScreenPart and its parent won't know about the event being triggered so you won't receive events in BindUIEventsOnStart(). To learn more about events click here","title":"Screen Part"},{"location":"screen_part.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"screen_part.html#introduction","text":"CmScreenPart is a part of the screen container for controls. This is an optional component. You can add controls to screens directly, but this separation of concerns will help you manage larger projects and reuse parts of your screen UI. You can have multiple CmScreenPart added to CmScreen .","title":"Introduction"},{"location":"screen_part.html#how-to-use","text":"NOTE: Before you will read about CmScreenPart please read about theming here , CmScreenManager here and CmScreen here . This way you will understand how it's working all-together To create your own CmScreenPart you will have to select if you will use theme or not. NOTE: If you won't use the theme then you can pass the default builtin CmThemeDefault empty theme interface like in example below: // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class MyMainScreen : CmScreen < CmThemeDefault > { ... // needed constructor public MyMainScreen ( CmScreenManager < CmThemeDefault > parent = null , VisualElement root = null ) : base ( parent , root ) {} ... } But in the theming section of the documentation we created a base interface for theme IMyExampleTheme and two implementations of themes MyThemeWhite and MyThemeBlack : So let's use this here. This is how it would look like // CmThemeDefault will be used as a base theme and this is the empty theme for filling purposes public class CmScreenPartTopSectionExampleSP : CmScreenPart < IMyExampleTheme > { public CmScreenPartTopSectionExampleSP ( CmScreen < IMyExampleTheme > screen ) : base ( screen ) { } public override void BindUIEventsOnStart ( CmUIEventsHandler eventsHandler ) { } public override CmControlBase MakeContent () { var row = new CmRow (); GetTheme (). StyleScreenPartContentRow ( row ); row . AddContent ( OptionButton ( \"Theme1\" , \"Theme1\" )); row . AddContent ( OptionButton ( \"Theme2\" , \"Theme2\" )); return row ; } public CmButton OptionButton ( string text , string name ) { var button = new CmButton ( text , cmUIEventsHandler : getUIEventsHandler ()); button . SetName ( name ); GetTheme (). StyleButton ( button ); return button ; } } This is a simple screen part that could be reused on screens.","title":"How to use"},{"location":"screen_part.html#makecontent","text":"The screen part is not CmControl. So when you want to add it to the screen you need to create content with controls from this screen part. That is why there is a method MakeContent () which will return some control or container with controls. In the above example, the content is built with a CmRow control container with two CmButtons added. To learn more about controls see there","title":"MakeContent()"},{"location":"screen_part.html#binduieventsonstart","text":"Here BindUIEventsOnStart () function is the same as in CmScreenManager, CmScreen but you can handle UI event whenever you want. CmScreenPart is the lowest place where you can handle events. Events will go up and will be handled in such direction : graph LR A[CmScreenPart.OnClick] --> B[CmScreen.OnClick] B --> C[CmScreenManager.OnClick] So you can handle events whenever you want. Note: when you create control you will pass CmUIEventsHandler as a parameter. You will have to pass CmUiEventHandler for current CmScreenPart by using the method of CmScreenPart.getUIEventsHandler(). This way events will be propagated upper in the view hierarchy like in the above diagram. If you create your event handler and pass it or null, then CmScreenPart and its parent won't know about the event being triggered so you won't receive events in BindUIEventsOnStart(). To learn more about events click here","title":"BindUIEventsOnStart()"},{"location":"theming.html","text":"CoDriven Advanced UI documentation Go back Themes CoDriven Advanced UI documentation Themes Introduction How to use Introduction Each game should have at least one theme so theming is optional, but if you won't use themes then you will have to use the default theme built in. This theme will not change your style. It is the empty theme for filling space purposes. It is strongly recommended to use at least one theme to make sure that your screen is not responsible for styling and this is delegated to themes. This will improve code readability and project maintenance. How to use To use themes you have to create a base interface that extends ICmThemeBase interface like this: public interface IMyExampleTheme : ICmThemeBase { public void StyleButton ( CmButton button ); } IMyExampleTheme interface will be passed as a generic argument to: screen manager: CmScreenManager\\< IMyExampleTheme > more about here . screens: CmScreen\\< IMyExampleTheme > here . (optionally) screen part: CmScreenPart\\< IMyExampleTheme > here . The next thing to do is to create your implementation for our theme We will style the button with modifiers - please read the modifiers section here . public interface MyThemeWhite : IMyExampleTheme { public void StyleButton ( CmButton button ) { // style with modifiers button . Modifiers . Button ( new CmModifierText ( CmSelector . DEFAULT_STATE ) . BackgroundColorRGBA ( Color . white ) . TextFontSize ( 30 . px ()) ); } } optionally you can create a second theme like this (as an example) public interface MyThemeBlack : IMyExampleTheme { public void StyleButton ( CmButton button ) { button . Modifiers . Button ( new CmModifierText ( CmSelector . DEFAULT_STATE ) . BackgroundColorRGBA ( Color . black ) ); } } As you can see we have two themes MyThemeWhite and MyThemeBlack . These themes you will have to add to the screen manager: // IMyExampleTheme is a base theme interface public class MyScreenManager : CmScreenManager < IMyExampleTheme > { ... //This is called by the system to add themes to the list public override void OnAddSupportedThemes ( List < IMyExampleTheme > themes ) { //Add all themes here for this screen manager themes . Add ( new MyThemeWhite ()); themes . Add ( new MyThemeBlack ()); } ... } and now you can use themes in your screens. Or change themes. More about screen manager here . You will use the theme in part of your code responsible for creating controls: public CmButton createMainButton ( string buttonTitle ) { //Create a simple button with buttonTitle and UI event handler from this screen to handle events in this screen var button = new CmButton ( buttonTitle , cmUIEventsHandler : GetCmUiEventsHandler ()); //Get the current assigned theme to this screen and use your function to style this button //This theme could be one of your added themes: MyThemeWhite, MyThemeBlack GetTheme (). StyleButton ( button ); return button ; } Now you know how to add a theme and use it.","title":"Theming"},{"location":"theming.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"theming.html#themes","text":"CoDriven Advanced UI documentation Themes Introduction How to use","title":"Themes"},{"location":"theming.html#introduction","text":"Each game should have at least one theme so theming is optional, but if you won't use themes then you will have to use the default theme built in. This theme will not change your style. It is the empty theme for filling space purposes. It is strongly recommended to use at least one theme to make sure that your screen is not responsible for styling and this is delegated to themes. This will improve code readability and project maintenance.","title":"Introduction"},{"location":"theming.html#how-to-use","text":"To use themes you have to create a base interface that extends ICmThemeBase interface like this: public interface IMyExampleTheme : ICmThemeBase { public void StyleButton ( CmButton button ); } IMyExampleTheme interface will be passed as a generic argument to: screen manager: CmScreenManager\\< IMyExampleTheme > more about here . screens: CmScreen\\< IMyExampleTheme > here . (optionally) screen part: CmScreenPart\\< IMyExampleTheme > here . The next thing to do is to create your implementation for our theme We will style the button with modifiers - please read the modifiers section here . public interface MyThemeWhite : IMyExampleTheme { public void StyleButton ( CmButton button ) { // style with modifiers button . Modifiers . Button ( new CmModifierText ( CmSelector . DEFAULT_STATE ) . BackgroundColorRGBA ( Color . white ) . TextFontSize ( 30 . px ()) ); } } optionally you can create a second theme like this (as an example) public interface MyThemeBlack : IMyExampleTheme { public void StyleButton ( CmButton button ) { button . Modifiers . Button ( new CmModifierText ( CmSelector . DEFAULT_STATE ) . BackgroundColorRGBA ( Color . black ) ); } } As you can see we have two themes MyThemeWhite and MyThemeBlack . These themes you will have to add to the screen manager: // IMyExampleTheme is a base theme interface public class MyScreenManager : CmScreenManager < IMyExampleTheme > { ... //This is called by the system to add themes to the list public override void OnAddSupportedThemes ( List < IMyExampleTheme > themes ) { //Add all themes here for this screen manager themes . Add ( new MyThemeWhite ()); themes . Add ( new MyThemeBlack ()); } ... } and now you can use themes in your screens. Or change themes. More about screen manager here . You will use the theme in part of your code responsible for creating controls: public CmButton createMainButton ( string buttonTitle ) { //Create a simple button with buttonTitle and UI event handler from this screen to handle events in this screen var button = new CmButton ( buttonTitle , cmUIEventsHandler : GetCmUiEventsHandler ()); //Get the current assigned theme to this screen and use your function to style this button //This theme could be one of your added themes: MyThemeWhite, MyThemeBlack GetTheme (). StyleButton ( button ); return button ; } Now you know how to add a theme and use it.","title":"How to use"},{"location":"translation_editor.html","text":"CoDriven Advanced UI documentation Go back Translation editor Language change runtime: CoDriven Advanced UI documentation Translation editor Language change runtime: Introduction Creating translations Get translation text for translation ID: Set current language: Introduction Translation editor will allow you to create translations for your texts, manage languages, and generate translation files. To create your translations open the translation editor by clicking in Unity from the top menu: windows -> CoDrivenAdvancedUI -> Translation Editor Translations are divided into columns. The first column \"Translation ID\" are ids for your translations because you will have to use the translation_ID name to access translation text. Other columns are just translations in any language. You can add language using \"Add language\" available above the table. To remove language click the red button with \"X\" on the the right side of your language in the table, but remember it will remove all the data that was added for that language. You can add translation ID and text for all languages assigned to this ID by using the button \"Add new line\" above the table. Creating translations So let's create an example translation for the \"Settings\" text: Click \"Add new line button\" and a new row will be created in the table. Click on the newly created text in the \"Translation ID\" row and enter your ID for translation. For example, enter \" str_settings\", click on the next row to the right of the \"English\" column and enter the \"Settings\" text. Optionally add other languages and translations for them. Finally click \"Save and generate CmGeneratedTranslations.cs\". This action will generate the static class for translation management called CmGeneratedTranslation.cs class. /** * THIS FILE IS GENERATED IN Translation editor. You can open the translation * editor in unity top bar \"windows->CoDriven Advanced UI->translation editor\" **/ public static class CmGeneratedTranslations { // LANGUAGE IDS public static readonly int LANGUAGE_English = 0 ; public static readonly int LANGUAGE_Polish = 1 ; // TRANSLATION IDS public static readonly int str_settings = 0 ; /** * Get string from translation id constant **/ public static string GetString ( int translactionID ) { return CmLanguageManager . GetString ( translactionID ); } public static void SetCurrentLang ( int langId ) { CmLanguageManager . SetCurrentLang ( langId ); } public static void setCurrentLang_English () { CmLanguageManager . SetCurrentLang ( \"English\" ); } public static void setCurrentLang_Polish () { CmLanguageManager . SetCurrentLang ( \"Polish\" ); } // TRANSLATION extension methods public static string text_str_settings < Theme > ( this CmScreen < Theme > screen ) where Theme : ICmThemeBase { return screen . GetString ( settings ); } public static string text_str_settings < Theme > ( this CmScreenPart < Theme > screen ) where Theme : ICmThemeBase { return screen . GetString ( settings ); } } As you can see this generated class will contain all your translation IDS as variable names with types of int and index value. // TRANSLATION IDS public static readonly int str_settings = 0 ; we added one so there is only one variable You can then use this class to access the translation by this ID for the currently selected language. Get translation text for translation ID: to get our \"settings\" translation for the currently selected language you can use: var settingsText = CmGeneratedTranslations . GetString ( CmGeneratedTranslations . str_settings ); As you noticed there are extension methods \"text_str_settings()\" generated for our str_settings translation ID that can be used as a shortcut for our previous code with CmGeneratedTranslations.GetString(CmGeneratedTranslations.str_settings); because text_str_settings() is extension method for CmScreenPart and CmScreen , you can use this method to get our str_settings translation for the current language like this: inside CmScreenPart code public class MyScreenPart : CmScreenPart < MyTheme > { .... void someMethod () { var settingsText = this . text_str_settings (); // use text settingsText for button text or other component or inside CmScreen code public class MyScreen : CmScreen < MyTheme > { .... void someMethod () { var settingsText = this . text_str_settings (); // use text settingsText for button text or other component this method name is built by connecting \"text_\" + our translation ID. - text_str_settings() in this example, because we had str_settings translation ID, because of that we have to keep the same naming rules for translation IDs as for a functions or variables Set current language: For example, to set English as the current language you can use CmGeneratedTranslations . setCurrentLang_English (); or CmGeneratedTranslations . SetCurrentLang ( CmGeneratedTranslations . LANGUAGE_English ) as you can see there are variables generated based on the translation editor table CmGeneratedTranslations.LANGUAGE_English, CmGeneratedTranslations.LANGUAGE_Polish are constants because we had two languages in our example table \"English\" and \"Polish\"","title":"Translation editor"},{"location":"translation_editor.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"translation_editor.html#translation-editor","text":"","title":"Translation editor"},{"location":"translation_editor.html#language-change-runtime","text":"CoDriven Advanced UI documentation Translation editor Language change runtime: Introduction Creating translations Get translation text for translation ID: Set current language:","title":"Language change runtime:"},{"location":"translation_editor.html#introduction","text":"Translation editor will allow you to create translations for your texts, manage languages, and generate translation files. To create your translations open the translation editor by clicking in Unity from the top menu: windows -> CoDrivenAdvancedUI -> Translation Editor Translations are divided into columns. The first column \"Translation ID\" are ids for your translations because you will have to use the translation_ID name to access translation text. Other columns are just translations in any language. You can add language using \"Add language\" available above the table. To remove language click the red button with \"X\" on the the right side of your language in the table, but remember it will remove all the data that was added for that language. You can add translation ID and text for all languages assigned to this ID by using the button \"Add new line\" above the table.","title":"Introduction"},{"location":"translation_editor.html#creating-translations","text":"So let's create an example translation for the \"Settings\" text: Click \"Add new line button\" and a new row will be created in the table. Click on the newly created text in the \"Translation ID\" row and enter your ID for translation. For example, enter \" str_settings\", click on the next row to the right of the \"English\" column and enter the \"Settings\" text. Optionally add other languages and translations for them. Finally click \"Save and generate CmGeneratedTranslations.cs\". This action will generate the static class for translation management called CmGeneratedTranslation.cs class. /** * THIS FILE IS GENERATED IN Translation editor. You can open the translation * editor in unity top bar \"windows->CoDriven Advanced UI->translation editor\" **/ public static class CmGeneratedTranslations { // LANGUAGE IDS public static readonly int LANGUAGE_English = 0 ; public static readonly int LANGUAGE_Polish = 1 ; // TRANSLATION IDS public static readonly int str_settings = 0 ; /** * Get string from translation id constant **/ public static string GetString ( int translactionID ) { return CmLanguageManager . GetString ( translactionID ); } public static void SetCurrentLang ( int langId ) { CmLanguageManager . SetCurrentLang ( langId ); } public static void setCurrentLang_English () { CmLanguageManager . SetCurrentLang ( \"English\" ); } public static void setCurrentLang_Polish () { CmLanguageManager . SetCurrentLang ( \"Polish\" ); } // TRANSLATION extension methods public static string text_str_settings < Theme > ( this CmScreen < Theme > screen ) where Theme : ICmThemeBase { return screen . GetString ( settings ); } public static string text_str_settings < Theme > ( this CmScreenPart < Theme > screen ) where Theme : ICmThemeBase { return screen . GetString ( settings ); } } As you can see this generated class will contain all your translation IDS as variable names with types of int and index value. // TRANSLATION IDS public static readonly int str_settings = 0 ; we added one so there is only one variable You can then use this class to access the translation by this ID for the currently selected language.","title":"Creating translations"},{"location":"translation_editor.html#get-translation-text-for-translation-id","text":"to get our \"settings\" translation for the currently selected language you can use: var settingsText = CmGeneratedTranslations . GetString ( CmGeneratedTranslations . str_settings ); As you noticed there are extension methods \"text_str_settings()\" generated for our str_settings translation ID that can be used as a shortcut for our previous code with CmGeneratedTranslations.GetString(CmGeneratedTranslations.str_settings); because text_str_settings() is extension method for CmScreenPart and CmScreen , you can use this method to get our str_settings translation for the current language like this: inside CmScreenPart code public class MyScreenPart : CmScreenPart < MyTheme > { .... void someMethod () { var settingsText = this . text_str_settings (); // use text settingsText for button text or other component or inside CmScreen code public class MyScreen : CmScreen < MyTheme > { .... void someMethod () { var settingsText = this . text_str_settings (); // use text settingsText for button text or other component this method name is built by connecting \"text_\" + our translation ID. - text_str_settings() in this example, because we had str_settings translation ID, because of that we have to keep the same naming rules for translation IDs as for a functions or variables","title":"Get translation text for translation ID:"},{"location":"translation_editor.html#set-current-language","text":"For example, to set English as the current language you can use CmGeneratedTranslations . setCurrentLang_English (); or CmGeneratedTranslations . SetCurrentLang ( CmGeneratedTranslations . LANGUAGE_English ) as you can see there are variables generated based on the translation editor table CmGeneratedTranslations.LANGUAGE_English, CmGeneratedTranslations.LANGUAGE_Polish are constants because we had two languages in our example table \"English\" and \"Polish\"","title":"Set current language:"},{"location":"ui_events.html","text":"CoDriven Advanced UI documentation Go back CmUIEventsHandler UI events are mapped internally to simple Class CmUIEventsHandler . This way you can easily use events in any place of your elements tree. The whole menu is built onto: CmScreenManager , CmScreen which is attached to CmScreenManager , CmScreenPart (optional) which is attached to CmScreen , finally your selected CmControl like CmToggle, or CmButton which is added to CmScreenPart Note: CmScreenPart is a helper class to manage everything into sections it is optional. So you can omit CmScreenPart from the above list and add your control to CmScreen directly. BindUIEventsOnStart() BindUIEventsOnStart () function is used to bind your event handling logic. For example on click event when the user select the button \"Start game\" This function exists in CmScreenManager, CmScreen, or CmScreenPart. Below is a part of the code for the main menu panel of the included example multiplayer game public class MainMenuPanelSp : CmScreenPart < ICmThemeTestBase > { public override void BindUIEventsOnStart ( CmUIEventsHandler uiEventsHandler ) { uiEventsHandler . ButtonClick = control => { //If the control name is \"MultiPlayer\" then the user clicks the button \"MultiPlayer\" if ( control . GetName (). Equals ( \"MultiPlayer\" )) { // SetCurrentScreen() is CmScreenPart function that will change the current screen by its name // ScreenTypes is an enum, so screens have enum names converted to a string //Using an enum helps to reduce magic strings here and there in-app, but also you can use this enum for screen names in many places SetCurrentScreen ( ScreenTypes . MAIN_MENU_MAP_SELECT . ToString ()); } //If the control name is \"Exit\" then the user clicks the button \"Exit\" if ( control . GetName (). Equals ( \"Exit\" )) { Application . Quit ( 0 ); } }; } } CmScreenPart is the lowest place where you can handle BindUIEventsOnStart events. Events will go up and will be handled in such direction : graph TD A[CmControl.OnClick] --> B[CmScreenPart.BindUIEventsOnStart] B[CmScreenPart.BindUIEventsOnStart] --> C[CmScreen.BindUIEventsOnStart] C --> D[CmScreenManager.BindUIEventsOnStart] So event will move through parents until it reaches the target which is CmScreenManager. You can handle onClick event on each step simultaneously. This way you can add on click sound globally for each onClick from all controls and add on click in CmScreenPart to handle some logic. Note: You won't have to create an instance of CmUIEventsHandler, because it is created internally for each class CmScreenPart, CmScreen, CmScreenManager . Each CmUIEventsHandler instance has a parent. CmScreenPart.CmUIEventsHandler has parent of CmScreen.CmUIEventsHandler etc. This way events will go up the parent's tree until they reach the grandparent CmScreenManager and propagation will stop. CmUIEventsHandler when you create your control you will have to pass CmUIEventsHandler instance. public class PlayerInGameStatsSp : CmScreenPart < ICmThemeTestBase > { public override void BindUIEventsOnStart ( CmUIEventsHandler uiEventsHandler ) { // handle image click or whatever ... } public CmImage createUserImage () { // so let's pass built-in event handler from PlayerInGameStatsSp var image = new CmImage ( this . getUIEventsHandler ()); return image ; } ... } If you create your instance of CmUIEventsHandler and pass it to the control constructor or pass null, then CmScreenPart and its Parent won't know about the event being triggered in controls so you won't receive events in BindUIEventsOnStart(). Of course, you can create your event handler like this, but you will have to handle events by yourself public class PlayerInGameStatsSp : CmScreenPart < ICmThemeTestBase > { public CmButton createExitButton () { var eventHandler = new CmUIEventsHandler ( \"MyEventHandler\" ); var button = new CmButton ( eventHandler ); button . setName ( \"Exit\" ); eventHandler . ButtonClick = control => { //If the control name is \"Exit\" then the user clicks the button \"Exit\" if ( control . GetName (). Equals ( \"Exit\" )) { Application . Quit ( 0 ); } }; //But now you will have to handle events using your event handler return button ; } ... } available events from CmUIEventsHandler CmUIEventsHandler has actions that will be called by controls when the event occurs in control. Here is a list public class CmUIEventsHandler { ..... public Action < CmControlBase , GeometryChangedEvent > GenericOnGeometryChange = null ; public Action < CmControlBase , PointerDownEvent > GenericPointerDown = null ; public Action < CmControlBase , PointerUpEvent > GenericPointerUp = null ; public Action < CmControlBase , PointerMoveEvent > GenericPointerMove = null ; public Action < CmControlBase , PointerOutEvent > GenericPointerOut = null ; public Action < CmControlBase > GenericMouseDown = null ; public Action < CmControlBase , ClickEvent > GenericClick = null ; public Action < CmControlBase > GenericMouseUp = null ; public Action < CmControlBase > GenericMouseEnter = null ; public Action < CmControlBase > GenericMouseLeave = null ; public Action < CmControlBase > GenericKeyUp = null ; public Action < CmControlBase > GenericKeyDown = null ; public Action < CmButton > ButtonClick = null ; public Action < CmTextField , String > TextFieldChange = null ; public Action < CmToggle , Boolean > ToggleCheckChange = null ; public Action < CmRadioButton , Boolean > RadioButtonCheckChange = null ; public Action < CmFoldout , Boolean > FoldoutCheckChange = null ; public Action < CmControlBase , float > SlidingHandleValueChange = null ; public Action < CmDropdownField , string > DropdownFieldSelect = null ; .... } you will assign your lambda to any of the above fields to handle the event for control. Each field is an action that will be executed with parameters like CmControlBase (the base class for controls) - this is control on which event has occurred. For example CmUIEventsHandler.ButtonClick from above is a type of Action for the button. So you will handle it like in previous examples: public override void BindUIEventsOnStart ( CmUIEventsHandler uiEventsHandler ) { // action ButtonClick will be called by the control when someone clicks a button and you will assign // lambda to that action to handle the event on the button click uiEventsHandler . ButtonClick = ( clicked_control ) => { if ( clicked_control . GetName (). Equals ( \"Exit\" )) { Application . Quit ( 0 ); } }; } } here is a description of the events CmUIEventsHandler field action name Action type description GenericOnGeometryChange Action\\<CmControlBase, GeometryChangedEvent> generic event called when control changed their geometry/calculated their size GenericPointerDown Action\\<CmControlBase, PointerDownEvent> generic event called when pointer is down GenericPointerUp Action\\<CmControlBase, PointerUpEvent> generic event called when pointer is up GenericPointerMove Action\\<CmControlBase, PointerMoveEvent> generic event called when pointer is moving GenericPointerOut Action\\<CmControlBase, PointerOutEvent> generic event called when pointer is out of control GenericMouseDown Action\\<CmControlBase> generic event called when mouse is down GenericClick Action\\<CmControlBase, ClickEvent> generic event called when click occurred on the control - this is generic not like ButtonClick event GenericMouseUp Action\\<CmControlBase> generic event called when mouse is up GenericMouseEnter Action\\<CmControlBase> generic event called when mouse is entering the control GenericMouseLeave Action\\<CmControlBase> generic event called when mouse is leaving the control GenericKeyUp Action\\<CmControlBase> generic event called when key is up GenericKeyDown Action\\<CmControlBase> generic event called when key is down ButtonClick Action\\<CmButton> Called when button is clicked TextFieldChange Action\\<CmTextField, String> called when text is changed in text field ToggleCheckChange Action\\<CmToggle, Boolean> called when toggle button check state is changed RadioButtonCheckChange Action\\<CmRadioButton, Boolean> called when radio button is checked FoldoutCheckChange Action\\<CmFoldout, Boolean> Called when foldout check change a state SlidingHandleValueChange Action\\<CmControlBase, float> Called when any slider, progressbar or scroll is scrolled DropdownFieldSelect Action\\<CmDropdownField, string> Called when dropdown field is selected","title":"UI Events"},{"location":"ui_events.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"ui_events.html#cmuieventshandler","text":"UI events are mapped internally to simple Class CmUIEventsHandler . This way you can easily use events in any place of your elements tree. The whole menu is built onto: CmScreenManager , CmScreen which is attached to CmScreenManager , CmScreenPart (optional) which is attached to CmScreen , finally your selected CmControl like CmToggle, or CmButton which is added to CmScreenPart Note: CmScreenPart is a helper class to manage everything into sections it is optional. So you can omit CmScreenPart from the above list and add your control to CmScreen directly.","title":"CmUIEventsHandler"},{"location":"ui_events.html#binduieventsonstart","text":"BindUIEventsOnStart () function is used to bind your event handling logic. For example on click event when the user select the button \"Start game\" This function exists in CmScreenManager, CmScreen, or CmScreenPart. Below is a part of the code for the main menu panel of the included example multiplayer game public class MainMenuPanelSp : CmScreenPart < ICmThemeTestBase > { public override void BindUIEventsOnStart ( CmUIEventsHandler uiEventsHandler ) { uiEventsHandler . ButtonClick = control => { //If the control name is \"MultiPlayer\" then the user clicks the button \"MultiPlayer\" if ( control . GetName (). Equals ( \"MultiPlayer\" )) { // SetCurrentScreen() is CmScreenPart function that will change the current screen by its name // ScreenTypes is an enum, so screens have enum names converted to a string //Using an enum helps to reduce magic strings here and there in-app, but also you can use this enum for screen names in many places SetCurrentScreen ( ScreenTypes . MAIN_MENU_MAP_SELECT . ToString ()); } //If the control name is \"Exit\" then the user clicks the button \"Exit\" if ( control . GetName (). Equals ( \"Exit\" )) { Application . Quit ( 0 ); } }; } } CmScreenPart is the lowest place where you can handle BindUIEventsOnStart events. Events will go up and will be handled in such direction : graph TD A[CmControl.OnClick] --> B[CmScreenPart.BindUIEventsOnStart] B[CmScreenPart.BindUIEventsOnStart] --> C[CmScreen.BindUIEventsOnStart] C --> D[CmScreenManager.BindUIEventsOnStart] So event will move through parents until it reaches the target which is CmScreenManager. You can handle onClick event on each step simultaneously. This way you can add on click sound globally for each onClick from all controls and add on click in CmScreenPart to handle some logic. Note: You won't have to create an instance of CmUIEventsHandler, because it is created internally for each class CmScreenPart, CmScreen, CmScreenManager . Each CmUIEventsHandler instance has a parent. CmScreenPart.CmUIEventsHandler has parent of CmScreen.CmUIEventsHandler etc. This way events will go up the parent's tree until they reach the grandparent CmScreenManager and propagation will stop.","title":"BindUIEventsOnStart()"},{"location":"ui_events.html#cmuieventshandler_1","text":"when you create your control you will have to pass CmUIEventsHandler instance. public class PlayerInGameStatsSp : CmScreenPart < ICmThemeTestBase > { public override void BindUIEventsOnStart ( CmUIEventsHandler uiEventsHandler ) { // handle image click or whatever ... } public CmImage createUserImage () { // so let's pass built-in event handler from PlayerInGameStatsSp var image = new CmImage ( this . getUIEventsHandler ()); return image ; } ... } If you create your instance of CmUIEventsHandler and pass it to the control constructor or pass null, then CmScreenPart and its Parent won't know about the event being triggered in controls so you won't receive events in BindUIEventsOnStart(). Of course, you can create your event handler like this, but you will have to handle events by yourself public class PlayerInGameStatsSp : CmScreenPart < ICmThemeTestBase > { public CmButton createExitButton () { var eventHandler = new CmUIEventsHandler ( \"MyEventHandler\" ); var button = new CmButton ( eventHandler ); button . setName ( \"Exit\" ); eventHandler . ButtonClick = control => { //If the control name is \"Exit\" then the user clicks the button \"Exit\" if ( control . GetName (). Equals ( \"Exit\" )) { Application . Quit ( 0 ); } }; //But now you will have to handle events using your event handler return button ; } ... }","title":"CmUIEventsHandler"},{"location":"ui_events.html#available-events-from-cmuieventshandler","text":"CmUIEventsHandler has actions that will be called by controls when the event occurs in control. Here is a list public class CmUIEventsHandler { ..... public Action < CmControlBase , GeometryChangedEvent > GenericOnGeometryChange = null ; public Action < CmControlBase , PointerDownEvent > GenericPointerDown = null ; public Action < CmControlBase , PointerUpEvent > GenericPointerUp = null ; public Action < CmControlBase , PointerMoveEvent > GenericPointerMove = null ; public Action < CmControlBase , PointerOutEvent > GenericPointerOut = null ; public Action < CmControlBase > GenericMouseDown = null ; public Action < CmControlBase , ClickEvent > GenericClick = null ; public Action < CmControlBase > GenericMouseUp = null ; public Action < CmControlBase > GenericMouseEnter = null ; public Action < CmControlBase > GenericMouseLeave = null ; public Action < CmControlBase > GenericKeyUp = null ; public Action < CmControlBase > GenericKeyDown = null ; public Action < CmButton > ButtonClick = null ; public Action < CmTextField , String > TextFieldChange = null ; public Action < CmToggle , Boolean > ToggleCheckChange = null ; public Action < CmRadioButton , Boolean > RadioButtonCheckChange = null ; public Action < CmFoldout , Boolean > FoldoutCheckChange = null ; public Action < CmControlBase , float > SlidingHandleValueChange = null ; public Action < CmDropdownField , string > DropdownFieldSelect = null ; .... } you will assign your lambda to any of the above fields to handle the event for control. Each field is an action that will be executed with parameters like CmControlBase (the base class for controls) - this is control on which event has occurred. For example CmUIEventsHandler.ButtonClick from above is a type of Action for the button. So you will handle it like in previous examples: public override void BindUIEventsOnStart ( CmUIEventsHandler uiEventsHandler ) { // action ButtonClick will be called by the control when someone clicks a button and you will assign // lambda to that action to handle the event on the button click uiEventsHandler . ButtonClick = ( clicked_control ) => { if ( clicked_control . GetName (). Equals ( \"Exit\" )) { Application . Quit ( 0 ); } }; } } here is a description of the events CmUIEventsHandler field action name Action type description GenericOnGeometryChange Action\\<CmControlBase, GeometryChangedEvent> generic event called when control changed their geometry/calculated their size GenericPointerDown Action\\<CmControlBase, PointerDownEvent> generic event called when pointer is down GenericPointerUp Action\\<CmControlBase, PointerUpEvent> generic event called when pointer is up GenericPointerMove Action\\<CmControlBase, PointerMoveEvent> generic event called when pointer is moving GenericPointerOut Action\\<CmControlBase, PointerOutEvent> generic event called when pointer is out of control GenericMouseDown Action\\<CmControlBase> generic event called when mouse is down GenericClick Action\\<CmControlBase, ClickEvent> generic event called when click occurred on the control - this is generic not like ButtonClick event GenericMouseUp Action\\<CmControlBase> generic event called when mouse is up GenericMouseEnter Action\\<CmControlBase> generic event called when mouse is entering the control GenericMouseLeave Action\\<CmControlBase> generic event called when mouse is leaving the control GenericKeyUp Action\\<CmControlBase> generic event called when key is up GenericKeyDown Action\\<CmControlBase> generic event called when key is down ButtonClick Action\\<CmButton> Called when button is clicked TextFieldChange Action\\<CmTextField, String> called when text is changed in text field ToggleCheckChange Action\\<CmToggle, Boolean> called when toggle button check state is changed RadioButtonCheckChange Action\\<CmRadioButton, Boolean> called when radio button is checked FoldoutCheckChange Action\\<CmFoldout, Boolean> Called when foldout check change a state SlidingHandleValueChange Action\\<CmControlBase, float> Called when any slider, progressbar or scroll is scrolled DropdownFieldSelect Action\\<CmDropdownField, string> Called when dropdown field is selected","title":"available events from CmUIEventsHandler"},{"location":"visual_controls.html","text":"CoDriven Advanced UI documentation Go back CoDriven Advanced UI controls Introduction CoDriven Advanced UI is based on UI toolkit. There are a few extension controls like CmDraggableScrollView and others, but mostly controls are the same as in UI toolkit. So what is the benefit of this?. CoDriven Advanced UI has a different approach to: you won't have to search for styles assigned to elements in controls, because styling controls is done using modifiers instead of USS/CSS code. This will make your menu development faster. More about this here , event handling is really easy. More about this here , separation of concerns in case of screens based on these controls and easy switching between screens by using Screen Manager, Screens and Screen Part. See Screen Manager , Screen and Screen Part styling dropdown is difficult in UI Toolkit and require to assign system uss as parent and here CoDriven Advanced UI will help you to forget about these problems and just style your dropdown. the whole system is better solution for styling, theming and language change. Controls graph TD ; A[CmControlBase] -- abstract class --> B[CmControlModifiable]; B -- abstract class --> C[CmControlContainer]; B -- abstract class --> D[CmControlModifiableForSelfHandleSubitems]; D --> E[Special container controls]; C --> F[All container controls]; B --> G[All normal controls] important - read this section before the documentation for indivitual controls. All CoDriven Advanced UI controls inherits from CmControlBase and all of them are holding reference to their counterparts controls from UI Toolkit. For example CmButton holds reference to Button, or CmTextField holds reference to TextField of UI Toolkit. You can get original control by using CmControlBase.GetVisualElement(); available methods for base control - CmControlBase public void SetName ( string name ) public string GetName () /// get or set index of control in focusable ring. The ring of controls that can take focus. /// You can set index of that focus then you can control which control will be focused next by changing /// active focused control. public void SetTabIndex ( int tabIndex ) public int GetTabIndex () // enabled state public virtual void SetEnabled ( bool enabled ) /// set custom selector. public void SetCustomSelector ( string modifierName ) /// remove custom selector. public void RemoveCustomSelector ( string modifierName ) /// control focused state public void Focus () public void Blur () public virtual void SetFocusable ( bool focusable ) // bring to front or back public void BringToFront () public void SendToBack () // control visibility public void Hide () public void Show () public virtual void SetVisible ( bool visible ) public bool IsVisible () almost all methods are self-explanatory. There are mostly delegates from base VisualElement methods from UI toolkit. so all controls have above methods. CmControlContainer - base controls container All container controls are inherit from base container CmControlContainer . You will add your own controls to that containers by calling control.AddContent(). For example: private CmColumn CreateLeftPanel () { var column = new CmColumn (); column . AddContent ( new CmButton (...)); column . AddContent ( new CmButton (...)); return column ; } finding control in CmControlContainer You can find any control inside container by calling: CmControlContainer. FindControl (\"optional_control_name\") CmControlContainer. Q (\"optional_control_name\") var label = cmControl . FindControl < CmLabel > (); label . SetText ( column . title ); Behaviours (AddControlBehaviour()) All controls inherited from CmControlModifiable which include function AddControlBehaviour Behaviours was made to add some functionality to control that can be reused. Currently there is one behavior available: CmControlFloatingWindowBehaviour - add this behaviour to any container to make it like floating Window that you can drag freely using mouse you can add your own behaviour by inherit the base class of behaviours CmControlBehaviourBase All controls containers CmColumn click for description CmRow click for description CmDropDownField click for description CmFoldout click for description CmGroupBox click for description CmPopupWindow click for description CmScrollView click for description Simple controls CmButton click for description CmDraggableScrollView click for description CmHelpBox click for description CmImage click for description CmLabel click for description CmListView click for description CmMultiColumnListView click for description CmProgressBar click for description CmRadioButton click for description CmScroller click for description CmSlider click for description CmTextField click for description CmToggle click for description Controls for Unity editor CmCurveFiled click for description CmEnumFlagsField click for description CmFloatField click for description CmIntegerField click for description CmLongField click for description CmMaskField click for description CmObjectField click for description CmPropertyField click for description CmTagField click for description CmToolbar click for description currently in editor controls are only delegates to unity version without \"Cm\" suffix, but it still helps with styling and events handling of these controls","title":"Controls"},{"location":"visual_controls.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"visual_controls.html#codriven-advanced-ui-controls","text":"","title":"CoDriven Advanced UI controls"},{"location":"visual_controls.html#introduction","text":"CoDriven Advanced UI is based on UI toolkit. There are a few extension controls like CmDraggableScrollView and others, but mostly controls are the same as in UI toolkit. So what is the benefit of this?. CoDriven Advanced UI has a different approach to: you won't have to search for styles assigned to elements in controls, because styling controls is done using modifiers instead of USS/CSS code. This will make your menu development faster. More about this here , event handling is really easy. More about this here , separation of concerns in case of screens based on these controls and easy switching between screens by using Screen Manager, Screens and Screen Part. See Screen Manager , Screen and Screen Part styling dropdown is difficult in UI Toolkit and require to assign system uss as parent and here CoDriven Advanced UI will help you to forget about these problems and just style your dropdown. the whole system is better solution for styling, theming and language change.","title":"Introduction"},{"location":"visual_controls.html#controls","text":"graph TD ; A[CmControlBase] -- abstract class --> B[CmControlModifiable]; B -- abstract class --> C[CmControlContainer]; B -- abstract class --> D[CmControlModifiableForSelfHandleSubitems]; D --> E[Special container controls]; C --> F[All container controls]; B --> G[All normal controls] important - read this section before the documentation for indivitual controls. All CoDriven Advanced UI controls inherits from CmControlBase and all of them are holding reference to their counterparts controls from UI Toolkit. For example CmButton holds reference to Button, or CmTextField holds reference to TextField of UI Toolkit. You can get original control by using CmControlBase.GetVisualElement();","title":"Controls"},{"location":"visual_controls.html#available-methods-for-base-control-cmcontrolbase","text":"public void SetName ( string name ) public string GetName () /// get or set index of control in focusable ring. The ring of controls that can take focus. /// You can set index of that focus then you can control which control will be focused next by changing /// active focused control. public void SetTabIndex ( int tabIndex ) public int GetTabIndex () // enabled state public virtual void SetEnabled ( bool enabled ) /// set custom selector. public void SetCustomSelector ( string modifierName ) /// remove custom selector. public void RemoveCustomSelector ( string modifierName ) /// control focused state public void Focus () public void Blur () public virtual void SetFocusable ( bool focusable ) // bring to front or back public void BringToFront () public void SendToBack () // control visibility public void Hide () public void Show () public virtual void SetVisible ( bool visible ) public bool IsVisible () almost all methods are self-explanatory. There are mostly delegates from base VisualElement methods from UI toolkit. so all controls have above methods.","title":"available methods for base control - CmControlBase"},{"location":"visual_controls.html#cmcontrolcontainer-base-controls-container","text":"All container controls are inherit from base container CmControlContainer . You will add your own controls to that containers by calling control.AddContent(). For example: private CmColumn CreateLeftPanel () { var column = new CmColumn (); column . AddContent ( new CmButton (...)); column . AddContent ( new CmButton (...)); return column ; }","title":"CmControlContainer - base controls container"},{"location":"visual_controls.html#finding-control-in-cmcontrolcontainer","text":"You can find any control inside container by calling: CmControlContainer. FindControl (\"optional_control_name\") CmControlContainer. Q (\"optional_control_name\") var label = cmControl . FindControl < CmLabel > (); label . SetText ( column . title );","title":"finding control in CmControlContainer"},{"location":"visual_controls.html#behaviours-addcontrolbehaviour","text":"All controls inherited from CmControlModifiable which include function AddControlBehaviour Behaviours was made to add some functionality to control that can be reused. Currently there is one behavior available: CmControlFloatingWindowBehaviour - add this behaviour to any container to make it like floating Window that you can drag freely using mouse you can add your own behaviour by inherit the base class of behaviours CmControlBehaviourBase","title":"Behaviours (AddControlBehaviour())"},{"location":"visual_controls.html#all-controls-containers","text":"CmColumn click for description CmRow click for description CmDropDownField click for description CmFoldout click for description CmGroupBox click for description CmPopupWindow click for description CmScrollView click for description","title":"All controls containers"},{"location":"visual_controls.html#simple-controls","text":"CmButton click for description CmDraggableScrollView click for description CmHelpBox click for description CmImage click for description CmLabel click for description CmListView click for description CmMultiColumnListView click for description CmProgressBar click for description CmRadioButton click for description CmScroller click for description CmSlider click for description CmTextField click for description CmToggle click for description","title":"Simple controls"},{"location":"visual_controls.html#controls-for-unity-editor","text":"CmCurveFiled click for description CmEnumFlagsField click for description CmFloatField click for description CmIntegerField click for description CmLongField click for description CmMaskField click for description CmObjectField click for description CmPropertyField click for description CmTagField click for description CmToolbar click for description currently in editor controls are only delegates to unity version without \"Cm\" suffix, but it still helps with styling and events handling of these controls","title":"Controls for Unity editor"},{"location":"controls/cmbutton.html","text":"CoDriven Advanced UI documentation Go back . CoDriven Advanced UI documentation introduction introduction graph TD ; A[CmControlBase] --> B[CmButton]; CmControlBase is the base control more in the introduction here CmButton CmButton is a button control. Is is based on VisualElement. CmButton someButton = new CmButton (); Style CmButton elements CmButton modifiers contains only one element to style - the \"Button\" public CmButton OptionButton ( bool enabled , string text , string name ) { var button = new CmButton ( text , cmUIEventsHandler : getUIEventsHandler ()); button . SetName ( name ); button . SetEnabled ( enabled ); // tyle Button element of Button control button . Modifiers . Button ( new CmModifierText ( CmSelector . DEFAULT_STATE ) . BackgroundColorRGBA ( new Color32 ( 3 , 3 , 32 , 255 )) . TextColorRGBA ( new Color32 ( 225 , 225 , 242 , 255 )) . Weight ( 0 ) . FlexDontShrink () // for hover selector ========================================================== . ____NextSelector ( CmSelector . HOVER ) . Scale ( 1.02f , 1.2f ) . TextOutlineWidth ( 2 ) . TextOutlineColorRGBA ( Color . black ) . BackgroundImageTintRGBA ( Color . cyan ) . TextFontSize ( 39 ) // for focused selector ========================================================== . ____NextSelector ( CmSelector . FOCUS ) . TextOutlineWidth ( 2 ) . TextFontSize ( 39 ) // copy common style from generic modifier builder // (you can copy it in multiple places to reduce code) // (you can copy this on all selectors - so create your own fucntion with common modifiers and copy) . CopyFrom ( scaleWithAnimation ()) // for disabled selector ========================================================== . ____NextSelector ( CmSelector . DISABLED ) . BackgroundImageTintRGBA ( _inputDisabledBgColor ) ); return button ; } private CmModifierBuilder scaleWithAnimation () { return new CmModifierBuilder ( CmSelector . DEFAULT_STATE ) // animation for 300 milliseconds . AnimDuration ( 300 ) // scale control a little bit . Scale ( 1.02f , 1.05f ); } to learn about modifiers for all controls click here","title":"CoDriven Advanced UI documentation"},{"location":"controls/cmbutton.html#codriven-advanced-ui-documentation","text":"Go back . CoDriven Advanced UI documentation introduction","title":"CoDriven Advanced UI documentation"},{"location":"controls/cmbutton.html#introduction","text":"graph TD ; A[CmControlBase] --> B[CmButton]; CmControlBase is the base control more in the introduction here","title":"introduction"},{"location":"controls/cmbutton.html#cmbutton","text":"CmButton is a button control. Is is based on VisualElement. CmButton someButton = new CmButton ();","title":"CmButton"},{"location":"controls/cmbutton.html#style-cmbutton-elements","text":"CmButton modifiers contains only one element to style - the \"Button\" public CmButton OptionButton ( bool enabled , string text , string name ) { var button = new CmButton ( text , cmUIEventsHandler : getUIEventsHandler ()); button . SetName ( name ); button . SetEnabled ( enabled ); // tyle Button element of Button control button . Modifiers . Button ( new CmModifierText ( CmSelector . DEFAULT_STATE ) . BackgroundColorRGBA ( new Color32 ( 3 , 3 , 32 , 255 )) . TextColorRGBA ( new Color32 ( 225 , 225 , 242 , 255 )) . Weight ( 0 ) . FlexDontShrink () // for hover selector ========================================================== . ____NextSelector ( CmSelector . HOVER ) . Scale ( 1.02f , 1.2f ) . TextOutlineWidth ( 2 ) . TextOutlineColorRGBA ( Color . black ) . BackgroundImageTintRGBA ( Color . cyan ) . TextFontSize ( 39 ) // for focused selector ========================================================== . ____NextSelector ( CmSelector . FOCUS ) . TextOutlineWidth ( 2 ) . TextFontSize ( 39 ) // copy common style from generic modifier builder // (you can copy it in multiple places to reduce code) // (you can copy this on all selectors - so create your own fucntion with common modifiers and copy) . CopyFrom ( scaleWithAnimation ()) // for disabled selector ========================================================== . ____NextSelector ( CmSelector . DISABLED ) . BackgroundImageTintRGBA ( _inputDisabledBgColor ) ); return button ; } private CmModifierBuilder scaleWithAnimation () { return new CmModifierBuilder ( CmSelector . DEFAULT_STATE ) // animation for 300 milliseconds . AnimDuration ( 300 ) // scale control a little bit . Scale ( 1.02f , 1.05f ); } to learn about modifiers for all controls click here","title":"Style CmButton elements"},{"location":"controls/cmcolumn.html","text":"CoDriven Advanced UI documentation Go back CmColumn CmColumn a container. Is is based on VisualElement. You can add controls to it by using: CmButton someButton = new CmButton (); CmColumn column = new CmColumn (); column . AddContent ( someButton ); All controls added to CmColumn will be hold in column way. To change how added controls will be positioned you can use modifier: CmColumn column = new CmColumn (); HorizontalArrangement allow you to set how added controls to this container will be positioned horizontally. Available values: START, CENTER, END, SPACE_BETWEEN, SPACE_AROUND. VerticalAlignment allow you to set how added controls to this container will be positioned vetrically. Available values: START, CENTER, END, STRETCH, TEXT_BASELINE STRETCH will stretch control to parent size vertically. Style CmColumn elements CmColumn modifiers contains only one element to style - the \"Container\" public CmColumn createColumn () { CmColumn column = new CmColumn (); column . Modifiers . Column ( new CmModifierColumn ( CmSelector . DEFAULT_STATE ) . HorizontalAlignment ( CmAlignment . START ) . VerticalArrangement ( CmArrangement . SPACE_BETWEEN ) . FillMaxWidth () . FillMaxHeight () ); return container ; } to learn about modifiers for all controls click here","title":"CmColumn"},{"location":"controls/cmcolumn.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"controls/cmcolumn.html#cmcolumn","text":"CmColumn a container. Is is based on VisualElement. You can add controls to it by using: CmButton someButton = new CmButton (); CmColumn column = new CmColumn (); column . AddContent ( someButton ); All controls added to CmColumn will be hold in column way. To change how added controls will be positioned you can use modifier: CmColumn column = new CmColumn (); HorizontalArrangement allow you to set how added controls to this container will be positioned horizontally. Available values: START, CENTER, END, SPACE_BETWEEN, SPACE_AROUND. VerticalAlignment allow you to set how added controls to this container will be positioned vetrically. Available values: START, CENTER, END, STRETCH, TEXT_BASELINE STRETCH will stretch control to parent size vertically.","title":"CmColumn"},{"location":"controls/cmcolumn.html#style-cmcolumn-elements","text":"CmColumn modifiers contains only one element to style - the \"Container\" public CmColumn createColumn () { CmColumn column = new CmColumn (); column . Modifiers . Column ( new CmModifierColumn ( CmSelector . DEFAULT_STATE ) . HorizontalAlignment ( CmAlignment . START ) . VerticalArrangement ( CmArrangement . SPACE_BETWEEN ) . FillMaxWidth () . FillMaxHeight () ); return container ; } to learn about modifiers for all controls click here","title":"Style CmColumn elements"},{"location":"controls/cmrow.html","text":"CoDriven Advanced UI documentation Go back CmRow CmRow is a container. It is based on VisualElement. You can add controls to it by using: CmButton someButton = new CmButton (); // CmRow row = new CmRow (); row . AddContent ( someButton ); This is similar to CmColumn read here All controls added to CmRow will be hold in column way. To change how added controls will be positioned you can use modifier: CmRow row = new CmRow (); row . Modifiers . Container ( new CmModifierRow ( CmSelector . DEFAULT_STATE ) . HorizontalArrangement ( CmArrangement . START ) . VerticalAlignment ( CmAlignment . CENTER ) ); HorizontalArrangement allow you to set how added controls to this container will be positioned horizontally. Available values: START, CENTER, END, SPACE_BETWEEN, SPACE_AROUND. VerticalAlignment allow you to set how added controls to this container will be positioned vetrically. Available values: START, CENTER, END, STRETCH, TEXT_BASELINE STRETCH will stretch control to parent size vertically. Style CmRow elements CmRow modifiers contains only one element to style - the \"Container\" public CmRow createRow () { CmRow row = new CmRow (); row . Modifiers . Container ( new CmModifierRow ( CmSelector . DEFAULT_STATE ) . HorizontalArrangement ( CmArrangement . CENTER ) . VerticalAlignment ( CmAlignment . STRETCH ) ); return container ; } to learn about modifiers for all controls click here","title":"CmRow"},{"location":"controls/cmrow.html#codriven-advanced-ui-documentation","text":"Go back","title":"CoDriven Advanced UI documentation"},{"location":"controls/cmrow.html#cmrow","text":"CmRow is a container. It is based on VisualElement. You can add controls to it by using: CmButton someButton = new CmButton (); // CmRow row = new CmRow (); row . AddContent ( someButton ); This is similar to CmColumn read here All controls added to CmRow will be hold in column way. To change how added controls will be positioned you can use modifier: CmRow row = new CmRow (); row . Modifiers . Container ( new CmModifierRow ( CmSelector . DEFAULT_STATE ) . HorizontalArrangement ( CmArrangement . START ) . VerticalAlignment ( CmAlignment . CENTER ) ); HorizontalArrangement allow you to set how added controls to this container will be positioned horizontally. Available values: START, CENTER, END, SPACE_BETWEEN, SPACE_AROUND. VerticalAlignment allow you to set how added controls to this container will be positioned vetrically. Available values: START, CENTER, END, STRETCH, TEXT_BASELINE STRETCH will stretch control to parent size vertically.","title":"CmRow"},{"location":"controls/cmrow.html#style-cmrow-elements","text":"CmRow modifiers contains only one element to style - the \"Container\" public CmRow createRow () { CmRow row = new CmRow (); row . Modifiers . Container ( new CmModifierRow ( CmSelector . DEFAULT_STATE ) . HorizontalArrangement ( CmArrangement . CENTER ) . VerticalAlignment ( CmAlignment . STRETCH ) ); return container ; } to learn about modifiers for all controls click here","title":"Style CmRow elements"},{"location":"tutorials/tutorials.html","text":"CoDriven Advanced UI documentation Introduction All below scenes contains UI_Toolkit_Prefab located in tool subfolder ui_prefabs/UI_Toolkit_Prefab.prefab Just add it to the scene and attach your own Screen Manager Monobehaviour. Or you can just create an empty object in the scene and add a UI document to it with typical panel settings and add an empty Source Asset (don't add your controls just add empty because it will be used by CoDriven Advanced UI as a UI document) Tutorials There are a few tutorial scenes added. Tutorials are placed in examples folder. Here is a list Simple one theme scene Scene is placed in examples\\simple\\one_theme\\scenes\\OneThemeExampleScene.unity . This scene contains simple buttons styled by one theme. An example is simple for faster learning purposes. Simple two theme scene with click actions Scene is placed in examples\\simple\\two_themes\\scenes\\TwoThemesExampleScene.unity . This scene is an extended version of the One Theme example. You can change the theme runtime. Simple CmScenePart usage example scene simple scene using CmScenePart. Scene is placed in examples\\simple\\screen_part\\scenes\\ScreenPartExampleScene.unity . This scene is an extended version of the One Theme example that just uses CmScreenPart as an example. Advanced tutorials Advanced full working game menu scenes. Scene is placed in examples\\advanced\\scenes\\ScreenPartExampleScene.unity . This scene is an extended version of One Theme example that just uses CmScreenPart as an example.","title":"Tutorial scenes"},{"location":"tutorials/tutorials.html#codriven-advanced-ui-documentation","text":"","title":"CoDriven Advanced UI documentation"},{"location":"tutorials/tutorials.html#introduction","text":"All below scenes contains UI_Toolkit_Prefab located in tool subfolder ui_prefabs/UI_Toolkit_Prefab.prefab Just add it to the scene and attach your own Screen Manager Monobehaviour. Or you can just create an empty object in the scene and add a UI document to it with typical panel settings and add an empty Source Asset (don't add your controls just add empty because it will be used by CoDriven Advanced UI as a UI document)","title":"Introduction"},{"location":"tutorials/tutorials.html#tutorials","text":"There are a few tutorial scenes added. Tutorials are placed in examples folder. Here is a list","title":"Tutorials"},{"location":"tutorials/tutorials.html#simple-one-theme-scene","text":"Scene is placed in examples\\simple\\one_theme\\scenes\\OneThemeExampleScene.unity . This scene contains simple buttons styled by one theme. An example is simple for faster learning purposes.","title":"Simple one theme scene"},{"location":"tutorials/tutorials.html#simple-two-theme-scene-with-click-actions","text":"Scene is placed in examples\\simple\\two_themes\\scenes\\TwoThemesExampleScene.unity . This scene is an extended version of the One Theme example. You can change the theme runtime.","title":"Simple two theme scene with click actions"},{"location":"tutorials/tutorials.html#simple-cmscenepart-usage-example-scene","text":"simple scene using CmScenePart. Scene is placed in examples\\simple\\screen_part\\scenes\\ScreenPartExampleScene.unity . This scene is an extended version of the One Theme example that just uses CmScreenPart as an example.","title":"Simple CmScenePart usage example scene"},{"location":"tutorials/tutorials.html#advanced-tutorials","text":"","title":"Advanced tutorials"},{"location":"tutorials/tutorials.html#advanced-full-working-game-menu-scenes","text":"Scene is placed in examples\\advanced\\scenes\\ScreenPartExampleScene.unity . This scene is an extended version of One Theme example that just uses CmScreenPart as an example.","title":"Advanced full working game menu scenes."}]}